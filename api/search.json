[{"id":"64fde8f4f830d3f6e242ae5002f50c98","title":"北航面向对象-展开表达式1","content":"简单表达式的展开题目重述\n\n\n\n\n\n\n\n\n给你一个表达式，一个表达式可以包含一个或者多个项，一个项可以包含多个因子。\n表达式内的项用加减号连接\n项内的因子用乘号连接\n因子为指数形式，底数可以为带符号整数、x或者一个表达式（用括号包起来），幂次仅能为非负的带符号整数。\n要求化简表达式为不含括号的形式。\n以上描述可以较为清晰简洁的重述出题目的框架，部分细节已经省略，需要注意的是表达式里面可能包含空白字符、表达式前可以加上一个符号，项的前面可以加上一个符号。\n思路初步解析由于表达式、项之前都可能存在多余的符号或者空白字符，我们先对字符串进行预处理如下：\n\n符号处理\n两个相同的符号处理为一个+\n两个不同的符号处理为一个+\n特判一下可能三个符号相连的情况\n\n\n空白字符处理\n删除所有的ascii == 32 || ascii == 9的字符\n\n\n\n输出结果分析我们也能很容易地看出，任何表达式在这种情况下都能够化简为多项式（Polynominal）的形式，也就是说，我们的式子应该表示为x的次方以及系数的形式，当然还有一个小细节就是x^0=1以及x的一次方就是x。\n对此我们构建一个Polynominal的类即可，从而达到面向对象课程的要求（逃）\n递归下降思路递归下降的概念我们早有耳闻，但是由于很多同学确实没有自己完整地写一个递归下降出来，以前出的题目都是填空的形式，因此这次作业挑战性也不算很小。\n我们的思路是依照表达式、项、因子这三个层次进行递归，简而言之就是：\n\n\n\n\n\n\n\n\n\n表达式里面拆出项，项里面拆出因子，因子计算出值（多项式），之后一层一层返回。\n一些细节具体而言就是，我输入一个字符串，生成一个表达式的类，这个类具有一个能够返回其本身化简后的多项式的一个方法，输入的就是经过预处理（上面说过的那个）的字符串，在方法内部的操作就是分割字符串为许多项。\n这个时候关键的一点来了，由于我们是递归，对于项来说我们依然可以建立一个类，这个类有一个可以返回其本身化简后的多项式的一个方法，而我们在表达式的方法内已经分割出来许多形似项的子字符串，这些子字符串作为项的类就能够通过调用其内部的返回多项式的方法计算出值，从而给到表达式的方法继续计算最终的值。\n当然此时你的项的这个方法内部可能是还没开始编写的，但是没关系，你只需要记住你的这个方法输入就是你的项，而且返回的值一定是个多项式即可，这样就能做到递归下降。\n同理，因子也具有类似的方法，而且由于因子的简单性，我们在大部分情况下可以直接从字符串计算出因子对应的多项式的值并且直接返回，至此，递归下降结束了，因为我们有了最终的返回值并且一步一步返回到项、表达式、最终结果里面。\n特殊情况由于因子里面可能包含表达式的括号，因此在匹配到表达式的时候应该继续调用表达式的这个返回多项式的这个方法，再次进行如上的递归即可。从调用者的角度来看，反正给进去的是一个字符串，得到的是一个多项式，那么拿到多项式之后我们再来加减乘就容易许多了。\n代码难点以及我的解法考虑到后续还需要加入三角函数以及自定义函数，利用代码来匹配字符串可能会显得可拓展性低（毕竟需要增添不少专用来匹配的代码），我在此选择了正则表达式来解决问题。\n我的思路是利用|来进行多路的选择，后续需要匹配三角函数或者别的函数的时候只需要在后面继续加多路选择即可。\n根据目前的情况，我们主要涉及的最困难的正则表达式是以下两种：\n从表达式匹配项对于表达式来说，内部包含的项除了括号内和[*^]的后续第一个符号一定不包含加减号，因此我们匹配的思路就是先匹配非嵌套括号，之后匹配非括号和加减号的数字以及其他符号，最后特判[*^][+-]?的这种情况。\n为了不泄露代码就不粘贴我的表达式了，但是我画了个图来表示：\n从项匹配因子这个相比之前的情况会更加复杂一些，如下：\n\nx的幂次因子，也就是[+-]后接一个\\w这种一次方的或者\\w^[+-]?\\d+这种多次方的。\n带括号的表达式因子，由于暂时不考虑嵌套，利用\\([^()]+\\)匹配非空括号即可，后续如果有多次方也就同上，加上^[+-]?\\d+即可。\n\n\n\n\n\n\n\n\n\n\n我后续画图里面可能用了\\w+来匹配x，但是因为就这一个是字母，暂时无伤大雅，后续添加三角函数后改成\\w之后再去扩写正则表达式即可。\n同样地，为了方便理解，我在这贴一张图：\n可拓展性？之前和助教沟通的时候被问到可拓展性的问题，私以为如果掌握正则表达式较好的同学对于|这个符号应该是很熟悉的，利用这个符号就可以实现如我上面贴的两张图内的多路分支的效果，由此遇上更加复杂的表达式也不过仅仅添加几个分支罢了。\n最关键的是，你完全不需要修改除了正则表达式之外的内容（当然你还是不得不写点因子处理的部分）就能够实现对于更复杂表达式的匹配，至少对于我来说写代码的压力小了太多了。\n\n\n\n\n\n\n\n\n\n举例来说：\n[0-9]+|[0-9]+[*^][0-9]+这个正则表达式就能够同时匹配上无符号数字和数字乘以（或者幂次）数字，如果你需要加上数字除以数字也很容易，在之后继续添加上（前略）|[0-9]+/[0-9]+即可，不需要修改之前的内容，仅仅添加即可。\n总结最近看到许多同学花费大量代码编写parse等类似方法，但是暂时没有看见完全利用了正则表达式的强大功能的解法，故在此分享，也希望这个思路能够给大家一些新的想法来写出更简洁的代码。\n毕竟面向对象咱就得狠狠写点好看的代码对吧 (QWQ)\n","slug":"buaa-oo-1","date":"2025-02-27T16:00:00.000Z","categories_index":"北航面向对象,学习笔记","tags_index":"面向对象,表达式,递归下降","author_index":"大仓鼠"},{"id":"557f6f42c54a8b328356c109feb241ff","title":"北航计组-预习14-流水线及其冒险","content":"流水线及其冒险流水线概述一个流水线电路的示例这个示例在三个周期中分别输入100、200、300，其中需要注意的是寄存器是在时钟上升沿触发写入，而CL1和CL2是下降沿，因此我们画出以下图片，分析其各个地方的值随Clock信号的变化：\n我们可以看上图中，数值就像“流水”一样，从左往右移动，也许这也是叫做流水线的一个原因吧。\n工作过程的形式表示一般来说我们采用列表的方法表示，水平方向按照流水线的执行顺序依次排下寄存器，竖直方向按照时钟上升沿前后顺序布局，得到下表：\n可以看出数据也算是依次往右下角流动。\n流水线架构模型我们回顾一些MIPS知识，一般来说数据通路包含五个阶段：取指令-译码-执行-访存-回写，我们反映到架构模型如下图：\n而流水线架构通过插入了若干个寄存器，这样把关键路径切割成了数段，下图中蓝色的就是寄存器：\n这样，在执行的时候后一个阶段和前一个阶段的指令就可以不一样，并且整条数据通路中的指令从前往后依次移动（如下文）。\n流水线执行特点其实就是每条指令在同一时刻占据了不同的阶段，并且每个上升沿（亦即每个cycle）从IM读出一条指令的时候，已经在流水线中的指令继续执行一步，前往数据通路的下一个阶段：\n当然我们之前也见过一些跳转指令，可能并没有占据所有阶段，但是对于N级流水线来说，大部分单条指令的执行周期都是N，也因此当流水线正常运行充满后，每个cycle都可以完成一条指令（即指令执行完毕）。\n\n一些不负责任的猜测\n本人不负责任猜测，遇到beq或者jr之类的不占据全部阶段的指令实际也会经理每个阶段，但是由于其数据通路本就不涉及某些阶段，于是相当于从上一个阶段的寄存器直接连接到下一个阶段，这样便于对齐。\n\n流水线寄存器命名感觉这段有点神金\n方法1用相邻两级的名字组合一下，这样可以清晰看出寄存器到底在哪里，但是名字略长了一些。\n方法2用其后的级的名字的某个字母命名，这样简洁但是易混淆。\n时钟驱动的流水线时空图和我们之前讲的“工作过程的形式表示”很想，这种图一般用于分析指令、周期、寄存器这三者的关系，因为其可以轻易得知不同级正在执行哪个指令：\n流水线数据通路我们下文还是针对MIPS-C0来说，仅有addu subu ori lw sw beq jal jr这些指令\n单周期数据通路我们对原来的数据通路小小处理一下，为了强调回写这一段，我们把RF复制一份拿到右侧，写入的地方接好线即可，并且对于NPC来说，我们在解析指令的时候单独分出imm16和imm26到NPC里面（本来是单独一个imm26位，我们在pre9里面修改的），这样便于分析beq和jal这俩计算PC的需求，不然这俩合并后分析较为复杂。\n流水线信号命名我们在每个信号的末尾添加特定的字母，用与区分信号所在的阶段，该阶段名字就是阶段前侧的寄存器名字，举例如下：\n示例：lw指令的执行\n第一个上升沿后\nPC驱动IM（组合逻辑）读取指令，lw指令被存入D寄存器\nPC驱动NPC（组合逻辑）输出PC+4，并且写入PC寄存器\n\n\n第二个上升沿后\nD驱动RF（组合逻辑）读取操作数\nD驱动EXT（组合逻辑）进行无符号数拓展，结果写入E寄存器\n\n\n第三个上升沿后\nE驱动ALU（组合逻辑）运算，结果写入M寄存器\n\n\n第四个上升沿后\nM驱动DM（组合逻辑）读取数据，结果写入W寄存器\n\n\n第五个上升沿后\nW寄存器将结果写入RF，寄存器号是指令内给定的rt\n\n\n\n因此我们可以得到流水线时空图的这部分：\n聪明如你可能会发现，数据从读出到写入之间相距3个时钟上升沿，但是指令流水线是一个接一个，那么在从lw指令之后的三条指令内，本应该被lw写入的寄存器的值还是“暂未变化”的状态，如果此时读写这个寄存器将会发生意料之外的错误。\n解决问题的方法就是转发（数据冒险部分介绍）\n信息同步我们先前的数据通路中NPC引出的PC4，翻译指令出来的偏移量Imm16和beq运算中的zero信号会在不同时间传入NPC。如下图，在第三个上升沿后，IM取出了add指令，PC寄存器写入了ori的地址，PC4F对应ori的PC+4；但是此时imm16对应的是add指令中的[15:0]这部分；与此同时，早先读取的beq指令计算出的zero信号传入NPC，可见这些关键的信息对应的都不是同一个指令，非常混乱。\n正常情况下，我们应该让beq指令的这三个值在同一时刻输入才行。因此我们需要修正“取出信号”的时机，把PC4Br和Imm16拉到和zero信号同一级：\n流水线性能我们先回顾一下单周期的CPU，最大的时钟频率取决于所有指令里面最耗时的一个，在MIPS-C0中为lw，如下表：\n\n\n\n指令\n读IM\n读RF\nALU\n写/取DM\n写RF\n\n\n\naddu\n200\n100\n200\n\n100\n\n\nsubu\n200\n100\n200\n\n100\n\n\nori\n200\n100\n200\n\n100\n\n\nlw\n200\n100\n200\n200\n100\n\n\nsw\n200\n100\n200\n200\n\n\n\nbeq\n200\n100\n200\n\n\n\n\njal\n200\n\n\n\n100\n\n\njr\n200\n100\n\n\n\n\n\n可见，单周期最大延迟为800ps，即频率上限为1.25GHz。但是流水线的最大频率仅取决于各段的最大延迟，这也很好理解，因为只需要保证一级执行完毕之后下一级正常执行即可，所以只需要对齐到每一段即可，此处最大延迟为200ps，时钟频率上限5GHz。\n我们也可以通过甘特图看出：单周期：流水线：\n\n\n\n\n\n\n指令集并行\n流水线使得CPU同一时刻能够执行多条指令，大大提高了CPU性能和利用率，这种技术也称之为指令级并行（ILP）\n\n\n流水线的特性流水线加速比单周期执行时间流水线执行时间\n\n若单周期数据通路切分为N段，那么流水线性能是单周期的N倍，即加速比。\n流水线各段执行时间不平衡，加速比会下降。\n填充和排放流水线也会使得加速比下降。\n流水线不能改善单指令的执行周期数，改善的是CPU吞吐率\n理论上来说，每个时钟周期CPU都能执行完毕一条指令\n\n\n流水线时钟频率受限于最慢的流水段\n\n指令级对流水线设计的影响\nMIPS指令级本就是面向流水线架构设计的\n所有的质量都是32位，取指令和译码在同一个周期内完成\n指令少，并且规范，各段位置不变，也正因此可以取指令同时译码\n存储器操作只有lw和sw\n存储器操作和地址对齐，因此访存的周期数是固定的（这句不太懂，后续来补一点理解）\n\n\n\n\n\n\n\n\n\n\n最后一句的一点理解：存储器操作中以字（word）为单位对齐，比如lw和sw，偏移量都是按照字来算，地址中的数据长度四个字节，也就是一个字，那么在访存的过程中可以直接访问一整个字而无需偏移（一般不会跨字访问存储器），所以访存一步就可以完成，一定时间内访存次数不会变化，周期数固定。\n个人理解，可能还需要修改，后续再说。\n流水线控制这个很好理解，因为控制信号也需要和CPU运行指令的需求同步，因此主控制器引出的控制信号也需要经过后几个寄存器之后才能到各个级里面。\n在流水线中，控制信号除了控制部件执行功能之外，还有一个正确的功能，即代表指令执行到哪个阶段，根据控制信号可以推断xx指令当前执行到xx级这种之类的。\n流水线冒险\n结构冒险\n需要的资源被占用\n\n\n数据冒险\n指令之间的依赖关系\n后续指令需要等待前序执行结束\n\n\n控制冒险\n指令流的方向依赖于前序指令的执行结果\n\n\n\n结构冒险后续指令需要的资源被前序指令占用，导致冲突。我们分析下面这样一种流水线：\n我们之前DM和IM都在同一个存储器内，而在第三个上升沿后，PC一直在从IM取数据，而lw指令此时也正在从DM取数据，此时，若DM和IM没有分开，就会导致读出的冲突，因此，流水线要求数据和指令分离存储，实际上IM和DM也就是分离的一级指令cache和一级数据cache。\n我们继续看到，在第四个上升沿后，or要从RF读数据，而lw在执行最后一步写入RF，此时读写也可能引发冲突，这时候解决方法就是：RF设计的时候必须读写端口分离（当然我们之前确实分离了，所以RF没啥问题）\n数据冒险当两条指令都读写同一个寄存器的时候就会发生数据的相关，对于程序员来说，编程的时候考虑的都是一行执行完毕之后执行下一行，也就是后续指令得获取到前序指令的结果。对于单周期来说，数据通路一次一条指令，和程序员的想法相同，但是流水线中指令会被同时执行，后执行的指令不一定能获取先执行的指令的结果，比如：\nasmlw  $t0, 0($t1)   # 写入t0\nadd $t2, 0($t0)   # 写入t2\nsub $t2, $t0, $t4 # 读取t0，写入t2，可以读到吗？计算结果？我们下文分析这段假设的代码：\nasm0   add $1, $2, $3\n4   sub $4, $1, $2\n8   or  $5, $1, $2\n12  add $6, $1, $2\n16  xor $7, $1, $2对于$1来说，当第五个上升沿，也就是从IM读出xor的时候，第一行的add才写入W寄存器，而第四行and指令此时从RF取数这一个阶段结束，因此在没有数据冒险的情况下，add下面的三行指令都会读出错误的数据，从第四个指令开始才会执行正确。\n\n\n\n\n\n\n提示\n对于RF来说，其写入可以不是（或者应该不是）沿上升沿，应该是沿下降沿写入，这样可以和RF前后的D和E流水线寄存器错开，防止冲突。也因此第四行的add指令可以正确读数字，因为在第四个上升沿（add从IM读入D寄存器）和第五个上升沿（RF取数）之间的第四个下降沿的时候，$1数据已经被更新了。\n\n\n\n\n\n\n\n\n\n特别注意\n我是后续\n后面学完转发电路后就会发现我上面在胡扯，其实解决方法是从W寄存器后也做一个转发，转发到RF后E寄存器前的位置作为E寄存器的输入，因为RF也说上升沿写入，因此在存入W寄存器之后的这个上升沿，也就是即将写入RF的这个上升沿的时候，RF的输出读数（组合逻辑）并未更新，而是直接往E寄存器去了，因此需要收到W寄存器直接连过来的转发电路才行。\n\n\n事实上来说，正如下图所示，在第三个时钟上升沿的时候，计算结果已经通过ALU存入M寄存器了，而sub指令正常走到了E寄存器，按道理来说是有办法让这个数据交给sub指令的，只需要想办法取出这个值，重新输入ALU即可，让ALU采用M寄存器的值而非E寄存器的值。\n解决策略：转发我们上文提到过了，只需要让输入ALU的数据从下一级寄存器取出即可，这样的操作叫做转发（或叫做旁路），即将尚未写入RF，但是已经在流水线寄存器的计算结果传递给相关功能部件的技术。\n比如我们为了解决add到sub的数据冒险，我们从M级寄存器后引出一条旁路到E级的ALU前的MUX：\n总结起来就是前递和选择，当然除了从M后引出数据，我们还要从W寄存器后引出数据，这样每行指令后的两行的问题就都能解决了：\nlw导致的数据冒险正常来说，lw的结果，也就是其从DM取值的结果，会在第三次上升沿后产生，而非像add的第二个上升沿，也就是单进行转发无法解决问题，因为直到sub进入读RF环节的时候，lw并没有真正取出数据，那么确实没有办法了吗？\n答案是有的，我们在第二个上升沿之后，锁定PC的值，冻结sub指令在D寄存器里面，并且插入一个nop指令，由此隔开一个间隙，执行第三上升沿，lw存到了M寄存器中，sub位置不变，这之后的下一个上升沿后侧，也就是第四个上升沿之后，lw成功取数（暂未存入$t0），通过我们之前搭的W到ALU旁路即可让sub在已经读出错误的$t0的情况下计算出正确的结果。\n转发电路汇总最新的结果可能会写入ALU后的M寄存器或者DM后的W寄存器，而需要最新结果的地方可能是D、E、M寄存器后的各个可能的位置：\n下表中，列代表从哪里转发出去，行代表哪里在接受转发\n\n\n\n\nM级ALU计算结果\nW级回写结果\n\n\n\nD级内接收\nrs，rt的值\nrs，rt的值\n\n\nE级内接收\nALU的A/B输入，rt的值\nALU的A/B输入，rt的值\n\n\nM级内接收\n\nDM的WD输入\n\n\n文字可能说的不清楚，我们看接线会更明白一些，就比如什么叫E接收rt的值，其实就是E级内往ALU的B输入接过去的线的地方，这里如果是lw之类的命令的话，实际含义就是rt，因此我们说这个叫接收rt的值：\n冒险控制器用来检测、分析冒险，控制流水线运行：\n我们依照流水线寄存器（D/E/M/W）来分割，xx寄存器后的叫做xx级，那么控制的策略就是：\n\nD级：分析与E/M/W的相关性，若无法解决则暂停，直至可以用转发解决\nE级：分析与M/W的相关性，决定是否转发\nM级：分析与W的相关性，决定是否转发\n\n暂停计算类指令（add，subi等）根据上文所述都可以通过转发完成，而只有Load类指令（lw，lh等），由于结果产生的相比RF取数会晚两个周期而非计算类的一个周期，因此需要将后续指令暂停一个周期。\n由图可见，当load类指令在E的时候才需要暂停一个周期（在还没访存的时候，下一个指令都要开始计算了），当load类指令在M可以通过通道2转发，用于替换原来D处早已读出的错误数据输入ALU；当load类指令在W级的时候，通过通道1转发，替换D处指令刚读出的错误数据进入E寄存器。\n即：\n\nD级为需要读取寄存器的指令\nE级为load类指令\n读和写的是同一个寄存器\n\n以上这种情况的时候就需要暂停，判断是否暂停的情况写成表达式如下：\n暂停的时候需要执行以下动作：\n\n冻结D：把后面的指令停留在D，利用寄存器的使能（D.en）\n清除E：E全部归0（亦即塞一个nop），利用寄存器的清除功能（E.clr）\n禁止PC：防止PC计数，保持之前的值，利用PC的使能（PC.en）\n\n利用我们上面表达式的变量，我们可以得知：\n\n编译优化可见，如果load后面的指令与load对应的寄存器相关，会导致CPU暂停一个周期，也就是我们说的加载延迟槽（load delay slot），这样会导致性能损失，因此我们为了编译优化，需要尽量把与load无关的指令放在load后面，避免出现暂停，比如以下两段计算加法的代码：\n控制冒险由于分支指令beq等会影响控制流，需要ALU输出的zero信号，也就是在比较结果产生之前，D级取指令无法确保正确。\n解决方法：狂塞仨nop，也就是一直清零几个寄存器。\n我们知道，需要在M寄存器后才会正确输出zero信号，若以beq读入D寄存器为第一个上升沿的话，在第三个上升沿后zero才是正确值，但是此时PC还在锁定状态，直至第四个上升沿的时候刷新为转移后的位置，第五个上升沿的时候取正确指令写入了D寄存器。（注意图中的imm16也经过了D/E/M这三个寄存器，从而和zero信号对齐）\n但是我们莫名其妙多了三个nop指令，很影响性能和我们的心情，你说万一气死了怎么办？别急，这个时候我们有两种方案：\n方案1：假设分支未发生也就是即使D级发现了是分支，但是不停顿继续执行，直到beq的时候根据zero的结果判断是否需要清除后面已经进入流水线的指令。那么完整数据通路如下即可：\n方案2：缩短分支延迟也就是提前判断是否相等，可以在RF后设置一个判断，这样可以提前两个周期得到beq的判断结果，这样每次需要转移的时候只需要废弃一条指令即可。但问题是，提前了比较的时候，由于我们采用的比较数据发生了变化，先前数据冒险的时候我们用转发到ALU解决了问题，如果当ALU在D寄存器的时候，前序指令涉及数据相关：\n\n依赖W级指令的计算结果：从W转发\n依赖M级指令的计算结果：从M转发\n依赖E级指令的计算结果：没得转，暂停一个周期，等待计算结果到达M级再转。\n\n\n更惨的是，遇上load类指令等的更长：\n\n依赖W级load：从W直接转发\n依赖M级load：没到DM转个几把，暂停一个周期到W再转\n依赖E级load：没到DM转个几把，暂停两个周期到W再转\n\n\n完整数据通路如下：\n更坏的是，其他更多非MIPS-C0指令可能会导致更奇怪的暂停。\n方案3：分支延迟槽即无论是否执行转移方向的指令，都执行分支指令后面的那条指令，这种技术就是分支延迟槽（branch delay slot），一个简单方案就是编译时每一个分支指令后都放一条nop作为延迟，优化的话可以考虑从分支之前的无关指令里面选一条放在分支指令后，作为延迟。\n\n\n\n\n\n\n一些理解\n说是延迟，我感觉是把本会浪费的地方单独赛点可以单独运行的指令，免得浪费的一种操作。\n\n比如下面两端代码：这里我们用or作为分支延迟槽，单独用or来减少nop的浪费，而其他指令由于涉及数据的相关，所以不能用其他指令作为分支延迟槽。\n当然，由于分支延迟槽的存在，支持分支延迟槽的CPU需要用PC+8作为计算偏移后地址的基地址，因为我们人为的塞了一条指令进去，同理，因为分支延迟槽，会导致jal指令存储在寄存器的值也需要是PC+8而不是PC+4\n小结\n冒险降低流水线效率\n因为会有暂停出现\n\n\n结构冒险是因为功能部件自身的冲突（单个部件又写又读）\n数据冒险是因为有数据相关（前序的结果是后续的输入等）\n控制冒险是由于控制信号确定前无法决定下条指令运行哪里（因此有分支延迟槽技术）\n\n流水线性能分析理论上来说，流水线每个时钟周期能执行完1条指令（CPI是每条指令占用的平均时钟周期），即：\n理想\n但是实际因为冒险，存在暂停的现象，所以：\n实际\n比如我们计算某种流水线的CPI，load占25%，store占10%，分支占11%，R型计算指令占54%，并且假设load导致暂停的概率是40%，并且只暂停一个周期，分支指令有25%概率预测失败，导致暂停一个周期。\n则我们可以计算\n\n两种CPU模型对比\n执行周期\n单周期：恒为1\n流水线：理想为1，但冒险存在导致大于1\n\n\n时钟频率\n单周期：关键路径决定\n流水线：分段有利于提升频率；转发和控制导致频率下降\n\n\n性能计算\n单周期：仅与执行的指令数及时钟周期宽度相关\n流水线：除了以上，还与指令频度及其相应的CPI相关\n\n\n设计要点\n单周期：数据通路是基础；控制信号仅与指令功能相关\n流水线：除了数据通路切割，还加入了转发；控制信号也分为主控制和冒险控制\n\n\n\n","slug":"buaa-co-pre-14","date":"2024-09-02T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理,CPU,流水线","author_index":"大仓鼠"},{"id":"8715491d8376050f4022829c0007c040","title":"北航计组-预习10-MIPS单周期控制","content":"MIPS单周期控制实现控制数据通路与控制器我们上一章，数据通路里面涉及了很多控制信号的取值，但是我们也发现：欸你这堆信号怎么接出去了？其实接到的就是我们的控制器，并且指令寄存器分线出来的Opcode和Funct这两段也作为控制器的输入了，为的就是识别不同的指令从而调整数据通路。\n\n控制信号取值矩阵我们这里用MIPS-C0指令集为例，其中对于不涉及的控制信号我们取“X”，表示未涉及，便于后续化简，而不涉及的存储功能部件必须设置为0而不是X。根据数据通路的知识，我们可以轻松得到下表，对应不同控制信号取值：\n\n里面部分取值用宏代替了。\n构建控制信号的布尔表达式每条指令用一个变量对应由于我们各类指令（R/I/J型）的不同指令区别就是opcode和funct这两个域，因此我们把opcode和funct的每一位都分开，并产生一些变量：\n\n在verilog里面，我们可以这样定义：\nverilog`define BEQ 6b000100\n`define ADDU 6b100000\n···\nassign beq = (op == `BEQ);        # op是6b000100的时候beq为1\nassign Rtype = (op == 6b000000);        # 判断是否R型指令\nassign addu = Rtype &amp; (funct == `ADDU); # 当Rtype为1的时候才会使得addu为1，反之addu一直为0，也就是可以使得funct不管用\n···使用指令变量构造控制信号我们先回到之前控制信号取值矩阵，矩阵内容的每一位都可以利用“与”构造出来，我在这里以M1Sel[1]为例，由于所有的XX都可以视作00便于化简，因此：\n\n此处是之前我们生成的指令变量（一位二进制数），同理M3Sel可以表示为：\n\n也就是当ori、lw、sw有（且仅有）一个为1的时候，M3Sel就为1。\n实现控制器我们上文可以发现，对于生成指令变量的时候，我们对每一位进行了==的对比，因此需要对每一位进行“与”的操作，最后得到一位的指令变量；而之后我们构造控制信号的时候用的全是号，因此我们需要对之前的指令变量进行一个“或”的操作，得到最后的控制信号。\n我们此处用AND阵列构造第一部分：\n\n\n\n\n\n\n接入方法\n这里ori是I型指令，对应的opcode是6b001101，左高位右低位，因此我们接入的时候，如果对应位是0，那么我们接入NOT后，如果是1，我们直接接在opx的后面即可。\n\n\n\n\n\n\n\n\n注意\n这里我们忽略了funct这几位，不过加上也很简单，只需要把opcode六位全部接到NOT的后面，之后在接入funct的6位，方法和opcode是一样的。\n\n之后我们继续用OR阵列构造第二部分，只要需要“或”进去的全部连线即可，下图仅为示例，只包含了一部分输入与输出：\n之后如下相连即可得到控制器：\n时钟方法一些术语\n建立时间：Setup Time，即输入信号在时钟上升沿之前就必须有效的时间\n保持时间：Hold Time，即输入信号在时钟上升沿之后仍然必须保持有效的时间\n输出延迟：CLK-to-Q，即输出信号在时钟上升沿之后输出有效值的时间\n\n电路的最大频率最大频率取决于最大延迟，也就是从建立输入开始到获得正确输出的这段时间。（当然，组合逻辑可能也有一部分延迟）\n关键路径即电路中任意两个寄存器之间的最大延迟，由于我们数据通路中有时序，也就是有时钟信号的只有PC、RF、DM这三位，而这三位本质都是寄存器（DM可能会慢一些，但是和寄存器差不多），因此我们计算最大延迟的时候只需要考虑寄存器之间的组合逻辑延迟：\n\n我们可以看出，时钟周期必须比关键路径大，不然信号不能正确传递到下一个寄存器，因为你必须第二个上升沿位于所有组合逻辑正确输出之后才行。\n比如我们分析addu如下：\n可以看出，直到WD信号被正确输出之后，我们再写入RF才是正确的，因此时钟周期必须比关键路径大。\n单周期性能我们假设RF读写延迟100ps，其他部件延迟均为200ps。我们根据数据通路分析延迟如下：\n可见，关键路径的延迟是800ps，因此所有指令的实际执行时间被对其到800ps，对应的时钟频率即：\n换用延迟更小的部件、缩短数据通路均可以提高时钟频率。\n","slug":"buaa-co-pre-10","date":"2024-08-23T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理,CPU,MIPS,控制","author_index":"大仓鼠"},{"id":"c3f30e18f1c39e433750df61f245507c","title":"北航计组-预习9-单周期数据通路工程化方法","content":"CPU形式建模综合方法－－单周期数据通路设计方法学概论MIPS-C0指令集\nMIPS-C0可以构造程序设计的绝大多数功能：\n\nlw（I）、sw（I）：存储指令的典型代表\naddu（R），subu（R）：运算类指令的典型代表\nbeq（I）：分支指令的典型代表\njal（J）、jr（R）：支持用的函数\n\n当然，以上这些指令包含了所有三类指令形式（R，I，J）\nMIPS-C0的RTL描述首先，所有指令必须经过取指令的一步：\n\nR-format：{op, rs, rt, rd, shamt, funct} &lt;- MEM[PC]\nI-format：{op, rs, rt, imm16} &lt;- MEM[PC]\nJ-format：{op, imm26} &lt;- MEM[PC]\n\n对于MIPS-C0来说，很简单就可以写出所有指令的RTL描述：\n\n\n\n\n\n\n回顾一下\n图中jal指令里面写入R[31]的操作实际上就是往$ra里面写，也就是返回地址。\n\n形式建模综合方法概述CPU\nQ：什么是CPU开发\nA：以某种CPU架构（比如单/多周期、流水线等）为模型，面向给定的指令集，设计并构造出以Verilog形式表达的CPU具体实现。\n\n\n\n\n\n\n\n\n\n\n\nVerilog是一种硬件描述语言，我把它理解成一种很新的写文章（x），你描述出来之后剩下的事情交给编译器就行。因此画出图再去写代码会更清晰，当然如果你是牛大笔的话也可以忽略……\n\nQ：什么是CPU架构模型\nA：以寄存器堆、ALU等部件为基础，描述各功能部件的基本接口特性以及相互之间的基本连接关系的模型。\n模型关注功能部件的外特性，即功能部件的某个具体功能与控制的对应关系（不关注具体实现）\n模型也灌注功能部件之间传递信息的基本依赖关系\n\n\n\n形式建模综合方法要点\n开发过程基于模型\n指的是CPU架构（比如单/多周期、流水线等）\n\n\n开发过程显式地氛围设计和实现两个环节\n设计：建模每条指令的数据通路和控制信号（当然，我还是建议画画图）\n实现；将设计结果用Verilog表达\n\n\n基于“系统-子系统”视角的建模层次\nCPU被视为系统，功能部件是子系统\n\n\n指令级别独立建模\n独立分析每条指令的操作，分析数据流、控制流程\n独立构造每条指令的数据通路以及相关功能部件的控制信号\n\n\n一次性系统级综合\n将分离的数据通路及控制信号取值高效合成为完整的数据通路和控制器\n\n\n\n\n\n\n\n\n\n什么是指令级别独立建模\n删繁就简：我个人认为就是单独分析每个指令RTL，分清数据通路和控制信号的各个成分，然后在先前的基础上连接部件即可。\n\n建模的基本表示方式数据通路的本质就是一个连接关系的集合，比如如下三个部件：\n此时连接关系就是{&lt;C.C2, A.A1&gt;, &lt;A.A2, B.B1&gt;, &lt;B.B2, C.C1&gt;}。\n当然，你也可以写成表格的形式，表示连接方式的集合：\n\nCPU模型确定后，指令的执行路径总体基调就定下来了（比如我们之前提到过的：取指令、译码、计算、访存、回写）\n构成指令执行路径的各个段之间有明确的依赖关系（比如PC驱动IM，ALU算加法后去从DM取值等等）\n\n建模的推理方法正因为我们上文提到的，指令执行过程之中各个块之间存在很强的逻辑依赖关系，建模数据通路的时候可以正向推理，也能倒推。\n\n\n\n\n\n\n\n\n\n举个栗子：我们需要算无符号加法的时候，要ALU参与，而ALU输入需要两个操作数，得从RF里面取，RF取数又需要译码后的指令，指令译码必须先取指令，取指令需要PC驱动，PC更新需要NPC……由此，就实现了一个倒推。\n倒推后，我们可以建立一个表格，包含各个模块的连接方式，比如对于addu来说：\n第一行为功能部件名字，第二行为功能部件的输入信号，第三行为与该输入信号连接的某个功能部件的输出信号。\n指令级别数据通路与控制器建模addu建模我在这里还是省掉一些繁文缛节，我们直接开始倒推：\n\n最后一个环节（-1）：运算结果写入RF，RF需要读一下rd寄存器编号，并且需要控制写入\n连接关系&lt;ALU.C, RF.WD&gt;, &lt;IM[15:11], RF.A3&gt;，控制信号RFWr = 1\n\n\n前一个环节（-2）：ALU完成加法运算，需要读入两个操作数，以及ALU的控制信号\n连接关系&lt;RF.RD1, ALU.A&gt;, &lt;RF.RD2, ALU.B&gt;，控制信号ALUOp : 'ADD'\n\n\n-3环节：RF取数，需要读取两个操作数寄存器的编号\n连接关系&lt;IM[25:21], RF.A1&gt;, &lt;IM[20:16], RF.A2&gt;\n\n\n-4环节：更新PC，并驱动IM取指令，IM需要PC连接，更新PC需要连接NPC，并且PC本身也得给NPC一个输入。\n连接关系&lt;PC.DO, NPC.PC&gt;, &lt;NPC.NPC, PC.DI&gt;, &lt;PC.DO, IM.A&gt;\n\n\n\n因此我们可以整理出这样一张表（虽然可能和我上面写的不太一样，不过无所谓啦，以这个为准）：\nsubu建模这里其实和addu十分相关，只有控制信号ALUOp改成SUB即可。\nori建模ori其实也很相似，但是相比R型指令，译码器后面的连线略有不同，并且ALU的操作控制信号取值为OR，还需要一个回写，写到rt里面。因此如下（回写那步PPT写错了，rd应该是rt）：\nlw建模lw有rs、rt寄存器的内容和一个imm16，ALU计算rs寄存器的内容，和imm16做有符号加法后从DM取对应地址的指，回写到rt寄存器里面。需要注意的是，由于是有符号数加法，我们修改了EXT的实现，加入了一个EXTOp的控制信号，因此之前用到EXT的建模都得修改。（回写那步PPT写错了，rd应该是rt）\nsw建模sw的计算过程和lw差不多，但是具体实现中由于是往DM写入，而不是RF，因此控制信号略有区别：\nbeq建模beq涉及相对跳转的问题，因此需要分线之后直接从IM取出立即数（编译的时候把label会翻译成立即数），然后往NPC里面输入，计算下一个PC，同时需要ALU做一次减法，给出一个判断0出来的zero控制信号：\njal建模jal需要改造的控制信号和NPC组件略多一些，当前前面的也需要略微修改：\n\n输入立即数从16位得扩展到26位\nBr控制信号改成[1:0]NPCOp这两位的控制信号\n2'b00：计算PC+4\n2'b01：计算beq地址\n2'b10：计算jal地址\n2'b11：计算jr地址（后面会用到的米奇妙妙工具）\n\n\n加入[31:0]PC4信号输出，即输出PC+4，用来写到寄存器堆RF的0x1F号寄存器（31号，也就是$ra）\n其他不变\n\n\n\n\n\n\n\n提示\n跳回是通过jr实现的。\n\n因此我们可以得到：\njr建模jr其实很简单，把rs读出来扔给PC或者NPC即可，但是考虑到“低耦合，高内聚”的需求，我们应该让NPC成为唯一会计算PC的部件，因此我们把读出来的值给NPC吧。我们继续修改NPC部件，加入一个[31:0]RA的输入信号，用于输入jr的地址。因此我们得到：\n\n\n\n\n\n\n\n注意\n有同学可能会问，哎呀你这个俩控制信号前后不一样啊，在一个时钟周期内咋办。好问题，实际上是覆写的，起作用的只有最后一个控制信号，也就是JR。因为PC有CLK上升沿触发的功能，在上升沿的时候起效的NPCOp就是JR，因此往PC写入的信号就是从RF.RD1接到NPC.RA的信号。\n\n数据通路综合方法汇聚+综合把所有的指令级别数据通用表汇聚在一张表里面，并总结在最后：\n注意信号之间的覆盖，比如说IM.D[25:0]把IM.D[15:0]覆盖了。\n构造MUX我们分析最后一行，输入源大于1个的地方都需要一个MUX选择器，因此我们可以在这一步才加入MUX，方便简单快捷，如下图：\n我们用了三个MUX，分别用不同颜色标记。\n编写Verilog我们设置好输入输出信号，verilog里面对PC/NPC/RF/ALU等等module全部做一遍实例化，举例上表的ALU.B的这个输入接的MUX如下：\nverilogwire [31:0]RD2, Ext, ALU_B;\n\nRF U_RF(..., RD2, ...);     // 实例化寄存器堆\nEXT U_EXT(..., Ext, ...);   // 实例化拓展单元\nALU U_ALU(..., ALU_B, ...); // 实例化ALU\n\n// 实例化二选一MUX\nMUX32_2_1 U_MUX_ALUB(RD2, Ext, ALU_B, ALUBSrc);","slug":"buaa-co-pre-9","date":"2024-08-17T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理,CPU,MIPS,数据通路","author_index":"大仓鼠"},{"id":"0a654409e2cd458ca3e033f4946855b9","title":"北航计组-预习8-MIPS数据通路","content":"MIPS数据通路概述电脑的五个组件一个电脑至少需要这些组件才能正常工作：\n\n控制器：control\n数据通路：datapath\n主存：memory\n输入设备：input\n输出设备：output\n\n\n处理器处理器的功能就是实现ISA（指令集架构）的指令，处理器包含数据通路和控制器：\n\n数据通路：包含用于实现指令的操作所必要的硬件。\n控制器；控制数据通路的行为的硬件。\n\nMIPS的轻量级指令子集\nADDU and SUBU：\naddu rd,rs,rt\nsubu rd,rs,rt\n\n\nOR Immediate:\nori rt,rs,imm16\n\n\nLOAD and STORE word:\nlw rt,rs,imm16\nsw rt,rs,imm16\n\n\nBRANCH:\nbeq rs,rt,imm16\n\n\n\n寄存器传递语言即RTL，是一种编译过程的中间语言，可以给出每一个指令的含义：\nCPU开发过程\n分析每条指令的RTL，梳理总结数据通路的设计需求。\n选择合适的数据通路功能部件。\n根据RTL组装数据通路，分析建立功能部件之间的正确连接。\n根据RTL，分析功能部件执行的功能，反推控制信号取值。\n生成控制器\n构建控制信号真值表，化简。\n根据最简表达式构建门电路。\n\n\n\n单周期CPU设计模型指令集功能需求\n存储器（MEM）：\n指令存储器和数据存储器（模拟cache结构）\n指令存储器只读\n数据存储器读写皆可\n\n\n寄存器堆（32个32bit寄存器）：\n能同时读出rs和rt两个寄存器\n可以写入到rt或者rd寄存器\n\n\n程序计数器PC\n下一条指令地址的计算单元\n拓展立即数：signed/unsigned\n执行运算的计算单元：\nadd/sub/or之类的\n\n\n\n\n\n\n\n\n\n一些重要缩写\n\n\n数据通路的抽象模型指令执行的主要步骤：取指令、译码、执行、访存、回写。\n\n\n\n\n\n\n提示\n为什么是五个阶段？因为MIPS里面的lw必须至少用到这五个阶段。当然，早期MIPS和其他CPU可能不到五个截断，现代的CPU可能有20~30个截断，都是合理的。\n\n\n第一步：取指令\nPC区段IM输出指令\nPC驱动NPC计算下一个PC的值\n\n第二步：译码\nIM驱动控制器（不在图中）分析指令的opcode和funct域得到具体指令含义\nIM驱动RF读出俩寄存器的值（rs,rt）\n\n第三步：执行\nRF输出的寄存器值驱动ALU完成相应计算\n加减乘除、移位、逻辑运算、比较运算\n计算lw和sw的地址\n\n\n\n第四步：访存\nlw：DM输入地址后，就输出数据\nsw：DM输入地址和写入的数据\n其他指令：绕过该环节\n\n第五步：回写\n将ALU的结构或者DM读出的数写回RF\nbeq、jal、jr、sw不涉及此环节\n注意RF在第三、第五阶段都有所涉及，前者用于读出，后者写入。\n\n数据通路基础部件建模MUX设计多选一选择器其实只需要选择输入的信号对应标号的数据即可：\nverilogmodule mux4(input [31:0]D0,\n            input [31:0]D1,\n            input [31:0]D2,\n            input [31:0]D3,\n            input [0:1]s,\n            output [31:0]y);\n    assign  y = (s == 2'b00)? D0:\n                (s == 2'b01)? D1:\n                (s == 2'b10)? D2:D3;\nendmodule寄存器我们的32bit寄存器需要32位的输入与输出，并且为了符合实际情况，需要一个写入使能与边缘触发的功能：\n\n使能为0的时候输出不变。\n使能为1的时候，在上升沿将输出变成输入信号。\n\n\n1位寄存器verilog// 一位的D寄存器，包含有使能enable和异步复位rst\nmodule d_ff(input d,\n            output q,\n            input clk,\n            input enable,\n            input rst);\n    reg r;\n    assign q = r;\n    always @(posedge clk | posedge rst) \n        if(rst) r &lt;= 1'b0;  // 当rst上升沿时，始终触发，与clk无关，因此为异步。\n        else if(enable) r &lt;= d;\nendmodule\n\n\n\n\n\n\n特别注意\n大部分verilog编译器都会有“维持输出”的实现，也就是当if分支没满足的时候，涉及的变量不会被修改，这个实现在这里是合理的，为我们补上了省略的else，但是有些时候不太合理，需要你自己设置其他情况，💥参见这里💥。\n\n32位寄存器verilog// 一位D寄存器d_ff模块已经定义过了，此处忽略\nmodule  d32(input [31:0]d,\n            output [31:0]q,\n            input clk,\n            input enable,\n            input rst);\n    genvar i;\n\n    generate\n        for(i = 0;i &lt; 32;i = i + 1)\n        begin:unit_d    // begin必须要有标签，作为生成的索引名字\n            d_ff inst_d_ff(d[i], q[i], clk, enable, rst);\n        end\n    endgenerate\n\nendmodulePC程序计数器PC的本质就是一个32位寄存器，并且在复位之后需要有一个确定的初始值，即第一条指令的地址（假设是32'h00000000），因此我们可以得知PC的输入输出信号与32位寄存器别无二致。\n\n\n\n\n信号名\n方向\n描述\n\n\n\nclk\ninput\n时钟信号\n\n\nreset\ninput\n复位信号\n\n\n[31:0]DI\ninput\n32位输入\n\n\n[31:0]DO\noutput\n32位输出\n\n\nNPC组件对于NPC来说，涉及各种寻址的问题，因此输入信号也很多样，包含大部份顺序指令，即，还有beq这样的相对寻址的16位imm，jal这样的伪直接寻址的26位imm，以及jr的寄存器32位寻址，因此可以抽象如下：\n其信号分析如下：\n\n\n\n信号名\n方向\n描述\n\n\n\n[31:0]PC\ninput\n当前指令地址\n\n\n[31:0]NPC\noutput\n下一条指令的地址\n\n\n[25:0]imm26\ninput\njal的26位偏移\n\n\n[31:0]A32\ninput\njr利用的寄存器保存的值\n\n\n[1:0]NPCOp\ninput\nNPC寻址模式的控制码\n\n\nZero\ninput\n相等的比较结果（0/1）\n\n\n\n\n\n\n\n\n\n注意\n对于beq来说，其RTL为：PC &lt;- (rs==rt)?(PC+4+sext(imm16)):(PC+4)\n因此我们需要用一个输入的wire来告诉NPC，rs和rt是否相等。\n\nRF寄存器堆根据需求，我们可以推知：\n\n寄存器堆包含32个寄存器\nRD1/RD2：读出的两个寄存器的值\nWD：写入的值\n\n\n寄存器编号输入\nA1/A2：读出寄存器编号\nA3：写入寄存器编号\n\n\n写入使能Wr\n时钟信号上升沿并且同时Wr为1的时候可以写入（时序逻辑）\n\n\n读出的时候可以视作31选1的MUX，视作组合逻辑（区别于写入）\n2个读出端口分别独立，不会互相干扰\n$0接地，应该是不需要选的吧（猜测）\n\n\n内部有31个32位寄存器，并且$0寄存器接地，保证时刻为0\nDEMUX：分离器/解码器\nN位编码产生个输出，并且有且仅有一个有效\n对于32个寄存器来说，需要5-32型DEMUX作为写入选择\n\n\n\n\nverilogmodule(input [31:0]WD, \n       input CLK, \n       input WE, \n       input [4:0]A1, \n       input [4:0]A2, \n       input [4:0]A3, \n       output [31:0]RD1, \n       output [31:0]RD2);\n\n    reg [31:0]rf[31:1];\n\n    always @(posedge CLK)\n        if (WE)\n            rf[A3] &lt;= WD;\n    \n    assign RD1 = (A1 == 5'b0) ? 32'b0:rf[A1];\n    assign RD2 = (A2 == 5'b0) ? 32'b0:rf[A2];\n\nendmodule指令存储器IM存储器可以理解成一个数组，需要的时候用下标取出里面的数，因此读出的操作可以视作组合逻辑。\n\n\n\n\n\n\n访问时间\n地址A需要有效一段时间后，RD才会输出正确的值，这段时间就叫做访问时间。\n\n数据存储器DM其实就是IM加入了写入功能，但是写入操作得满足时序逻辑，因此除了WD输入，还需要使能Wr盒时钟CLK信号。\n\n读：Wr无所谓，最好是0，下标A的单元数据在访问时间后从RD输出\n写：CLK上升沿并且Wr=1有效时候，WD写入下标A的单元。\n\nverilogmodule MEM4KB(input [9:0]A, \n              input [31:0]DI,\n              output [31:0]DO,\n              input Wr, \n              input CLK);\n    reg [31:0]array[1023:0]\n\n    assign DO = array[A];\n\n    always @(posedge CLK)\n        if(Wr)\n            array[A] &lt;= DI;\nendmodule\n\n\n\n\n\n\n注意\nCLK信号与输出无关，和之前那些存储、寄存器之类的是一样的。\nVerilog代码里面的寄存器在实际实现的时候会用定制的库而非reg（有一年P8的存储器得用FPGA内置的块存储器）\n\n算数单元ALU计算需求：加、减、或、相等。不过相等可以用减法与判断全0代替。\n减法运算计算&amp;Y=A-B&amp;可以等价为计算利用补码的计算规则可以得到：\n因此可以用加法器构造减法，对输入取反之后cin作为进位置1：\n相等先执行减法，之后介入一个判断为0的电路即可，其中一种实现是利用个或门实现的：\n集成\n\nM1：0对于加法，1对应减法\nM2：0对应取加减法结果，1对应取OR的结果\nCin：执行加法的时候取0，减法的时候取1\nF：功能控制，如下\n\n\n\n\nF\n功能\n\n\n\n2'b00\n加\n\n\n2'b01\n减\n\n\n2'b10\n或\n\n\nVerilog建模verilog`define ALU_ADDU 2'b00\n`define ALU_SUBU 2'b01\n`define ALU_OR   2'b10\n\nmodule ALU4(input [3:0]a,\n            input [3:0]b,\n            input [2:0]op,\n            output [3:0]c);\n\n    assign c = (op == ALU_ADDU)? (a + b) :\n               (op == ALU_SUBU)? (a + ~b + 1) :\n               (op == ALU_OR)? (a | b) :\n               4'b0000; // 保留\n\nendmodule组装数据通路\n每条指令都有各自的功能需求，对应的功能部件及其连接关系也是不同的。\n数据通路就是所有功能部件及其连接关系的集合。\n\n取指令\nPC驱动IM取出指令\nPC驱动NPC，得到新的地址（比如PC+4）之后更新到PC里面\n\n\n指令分解其实就是和之前讲的域一样，把指令分成N个域，比如这样：\nverilog// ...\nassign funct = Instr[5:0];\nassign imm16 = Instr[15:0];\nassign imm26 = Instr[25:0];\n// ...\nADDU &amp; SUBADDU: R[rd]&lt;-R[rs]+R[rt]需要一个寄存器堆和ALU组合，RF要求两路输出和一路写回信号，如下：当然rs，rt，rd不要搞混了，得按顺序来，并且写入使能RFWr应该置高电位，保证能够写入。\nORIORI:R[rt]&lt;-R[rs] OR zero_ext(imm16)ori里面包含16位立即数，较为特殊，根据RTL来看需要进行无符号数的0拓展，从16位补高位的0到32位：\nverilogmodule EXT(input [15:0]Imm16,\n           output [31:0]Ext);\n    assign Ext = &lt;!--swig￼0--&gt;, Imm16};\nendmodule我们对之前的数据通路加上一个刚写好的EXT，以及两个MUX，一个（WRSel）是为了写入到rt，另一个（BSel）是为了作为ALU的输入。\nLWLW:R[rt]&lt;-MEM[R[rs]+sign_ext(imm16)]分析LW的RTL，由于需要正负偏移位的立即数imm16，但是计算的时候必须32位，因此需要对imm16进行有符号数的拓展：需要加入EXT的控制信号EXTOp（保证高内聚，低耦合）\nverilog`define ZEXT 0\nmodule EXT(input [15:0]Imm16,\n           output [31:0]Ext,\n           input EXTOp);\n    assign Ext = (EXTOp == `ZEXT)? &lt;!--swig￼1--&gt;, Imm16}:\n                                   &lt;!--swig￼2--&gt;, Imm16};\nendmodule我们修改EXT之后加入EXTOp信号，但是对于LW来说还需要数据存储，也就是DM，还需要回写到寄存器堆里面，因此我们继续修改数据通路：\nSWSW:MEM[R[rs]+sign_ext(imm16)]&lt;-R[rt]与lw相反的是写入方向，只需要把寄存器堆的第二个输出RD2，也就是从rt取出来的值写道数据存储器的WD即可：\nBEQ我们之前已经折腾过ALU了，让ALU实现了0的比较功能，那么这里只需要把结果，也就是zero信号传给NPC即可：\nBEQ(包含了一点NPC):\ncif (R[rs] == R[rt])\n    PC &lt;- PC + 4 + sign_ext(imm16 &lt;&lt; 2);\nelse\n    PC &lt;- PC + 4;NPC对于NPC来说，除了让PC直接加上四，还需要考虑beq指令，我们上文已经提到过了：\n其中Br信号为beq指令标志，1代表指令是beq，0代表否。那么当Br和zero都是1的时候才会使用MUX的1号通道，将imm16拓展，和PC相加得到下一条跳转后的指令；否则，Br和zero至多有一个为1的时候，说明条件不满足，那么顺序执行指令即可。\n组装！\n控制介绍这部分其实就是反推控制信号的过程。\n\nEXTOp：0代表无符号补全，1代表有符号补全\nBSel：0代表从RD2输入到ALU，1代表采用imm16拓展后的数\nALUOp：区分add和sub以及or\nBr：beq采用信号，0代表直接PC+4，1代表采用branch结果\nDMWr：1代表可以写入数据存储器，0不行\nWDSel：0代表从ALU输出写入寄存器，1代表从DM读入寄存器\nWRSel：0代表写入到rt对于寄存器，1代表写入rd对应寄存器\nRFWr：1代表能够写入寄存器，0代表无法写入\n\n","slug":"buaa-co-pre-8","date":"2024-08-14T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理,CPU,MIPS,数据通路","author_index":"大仓鼠"},{"id":"a9e7097f73f9d5d3ab8d9233687f3fe7","title":"北航计组-预习7-机器语言3","content":"机器语言3存储型程序概念挺概念的，预习的时候看一下差不多得了，期末复习指不定会考（?）\n程序存储概念\n指令以二进制方式被编码\n程序存储在存储器中；可以从存储器中读取程序也可以写入程序，程序和数据以相同方式存储\n简化了计算机系统的软件/硬件设计\n存储器技术既可以存储数据，也可以存储程序\n由于存储在存储器单元中，因此指令和数据都有地址\n\n简单来说，程序就是一串01数据，和其他数据别无二致。\n二进制兼容正如我们上面所说，程序以二进制的形式发布，并且程序与指令集直接有很强的相关性。\n对于新机器来说，较新的指令集有更多的新指令，因此可以运行基于新指令集的新程序，但是新机器也最好适配老程序，即向后兼容。\n指令是什么MIPS里面所有指令的二进制宽度都是一个字，即32位。\n这32位会被划定成若干个域，即代表特定含义的若干位，同一指令的不同域的含义不同，但是对于不同指令来说，不同指令的同一个域的意思大致相同。和数据区分开的是，数据的32位一般视作一个整体，不是多个域。\nMIPS的三类指令\nI型指令：包含立即数的指令\n除了addi、addiu这类比较明显的，lw sw由于包含偏移的立即数，也属于I型，更隐蔽的还有beq bne这俩B类指令，由于其第三个参数其实也属于一个16位的数，并且是直接用的，因此也是I类指令。\n\n\nJ型指令：j和jal。\nR型指令：除了以上这两类之外其他的指令，即寄存器型指令。（srl和jr都是R型指令）\n\n分类可能看起来有些奇怪，我们下文会解释的，其实挺正常。\nR-指令格式这类指令包含六个域，分别的长度和名字如下：\n\n\n\n\n\n\n\n\n\n每个域都被视为无符号整数。\n指令分析\nopcode(6):代表指令操作，R型指令的opcode固定为0b000000。\nfunct(6):与opcode组合，精确定义指令的具体操作，不同指令的funct不同。（主要服务于R型指令，因为R真的多）\n因此可见，MIPS最多有64条R型指令。\n\n\nrs(5):指定第一个操作数，亦即source寄存器。\nrt(5):指定第二个操作数，亦即target寄存器。\nrd(5):指定结果回写的寄存器，亦即destination寄存器。\n比如add  rd,rs,rt\n有的域可能不生效，和具体指令有关。\nMIPS只有32个寄存器，因此5位二进制足够。\n\n\nshamt(5):移位指令中的移位位数（杀……杀马特？）。\n一个寄存器只有32位，因此移位也只需要5位二进制。\n除了移位指令，该域固定为0b00000\n\n\n\n指令示例指令：add $8,$9,$10含义：把$9和$10寄存器里面的有符号数加起来（检测溢出），存储到$8里面。\n域（10进制）:\n\n\n\n高位\n0\n9\n10\n8\n32\n低位\n\n\n\n域（2进制）：\n\n\n\n高位\n000000\n01001\n01010\n01000\n100000\n低位\n\n\n\n\n\n\n\n\n\n\n\n\n如上的二进制编码其实就是机器码\n\n两种略微神金的表达方式\n16进制：0x012A402010进制：19546144一般不会写10进制的……\n\n特殊指令-NOPNOP即对应16进制为0x00000000的指令，按照R型指令翻译：\n\nopcode：0b000000，R型指令\nrs：0b00000，$0\nrt：0b00000，$0\nrd：此处无意义\nshamt：0b00000，移位为0\nfunct：0b000000，代表sll指令，逻辑左移\n\n因此指令为：sll $0,$0,0，功能是解决流水线冲突，是一条特殊指令。\nI-指令格式I型指令只包含四个域，分别大小和命名如下：\n可见前三个域和R型指令相同，最重要的是opcode也在相同位置。\n指令分析\nopcode(6):代表指令操作，此处为一个非0编码。\nrs(5):指定第一个操作数，亦即source寄存器。\nrt(5):指定第二个操作数，亦即target寄存器。\ntarget并非一直都是“目标”，比如lw里面rt就是代表的“读取”\n\n\nimmediate(16):无符号或者有符号数\n无符号：位运算指令（and、or等），小于置位指令（slti等）\n有符号：分支指令（beq、bne等），访存指令（lw、rw等）\n\n\n\n指令示例指令：addi $21,$22,-50含义：把$22寄存器里面的有符号数和加起来（检测溢出），存储到$21里面。\n域（10进制）:\n\n\n\n高位\n8\n22\n21\n-50\n低位\n\n\n\n域（2进制）：\n\n\n\n高位\n001000\n10110\n10101\n1111111111001110\n低位\n\n\n\n32位立即数有宝贝可能会问，哎呀那addi，ori等这些立即数指令不都是可以塞32位立即数吗，那怎么你之前只有16位的空间呢。\n\n\n\n\n\n\n\n\n\n不难看出addi，ori，slti等等涉及32位立即数的指令基本都是伪指令。\n解决方法-lui我们增加了一条新的指令：lui，即Load Upper Immediate。\n\n用法：lui reg,imm\n即把16位的imm写到reg的高16位，reg的低16位全置0。\n\n比如，我们需要执行addi $t0,$t0,0xABABCDCD这一条伪指令，汇编时会被转换为三条：\nasmlui $at, 0xABAB     # 高16位\nori $at, 0xCDCD     # 低16位\nadd $t0, $t0, $at   # 赋值给$t0\n\n\n\n\n\n\n注意\n$at不应该由程序员自己使用，只应该交给汇编器使用，手工编写的时候应该避开$at。\n\nB类指令即分支指令，比如beq src1,src2,label，其中第三个操作数对应的就是指令里面的立即数。（当然rt域也并非一定是寄存器）\n分支指令一般用于构造while、if-else之类的结构，跳转范围一般是几十条指令，不会太远，如果是函数调用之类的建议使用J型指令。\n\n\n\n\n\n\nPC相对寻址\n对于B类指令，基本都是PC相对寻址，具体计算方法是：\n\n若结果为假：\n若结果为真：\n\n可能有人疑问为什么要乘四，这涉及我上次预习提到过的，存储器按照字节编址，但是指令都是按字对齐，因此对于指令来说，后两位一定为0，因为每两条指令之间存储器地址差值为4，也就是0b100，所以B类指令的立即数并不需要浪费两位，于是为了扩大一点有效范围，因此只记录除了最低两位后的16位。\n至于为什么基地址是，这个我们后续慢慢看。\n\n\n\n\n\n\n\n\n\n\n我们对B类指令的跳转范围估算一下，16位的二进制数是，由于立即数要乘以四，所以转移的指令数也是，按照单向估算，一行C语言大约对应10条指令，因此可以转移的代码块大小大约行。让我想起来一个经典笑话：判断一个10000以内的数是奇数还是偶数，一老哥写了10000个switch-case，结果没法编译，手机拍屏发贴吧问。这里没法编译我估计就是因为超出了跳转范围（也许）。\n一个B类指令的示例asmLoop:\nbeq     $9, $0, End\naddu    $8, $8, $10\naddiu   $9, $9, -1\nj       Loop\nEnd:我们得认识到，label的本质就是一个16位立即数，这个label会在汇编编译的时候被“替换”成一个立即数，其值是从该指令到对应label的距离，这一步编译器会帮我们完成，所以如果你真的在这里用了非标号的立即数的话，一定要注意，这个时候就不是编译器帮你做这个了，你得自己数清楚，修改代码的时候这个立即数有可能需要修改，不然bug就来了。如上代码中，End标号对应立即数就是3，因为需要跳过beq到下面End:标号之间的三条指令。\n\n\n\n\n\n\n\n\n\nbeq的opcode是4（查手册），因此构造上面那个B类指令可以构造出：四个域分别为4、9、0、3，那么表示为二进制为：0b 000100 01001 00000 0000000000000011\n大范围跳转当你需要跳转很大区域的时候，可以组合使用B类指令和J类指令，利用J类指令跳转范围更大的特点实现跳转：\nasmbne $s0, $0, Next   # s0里面等于0的时候判断为假，执行下一条j指令\nj   Far             # 跳转很远的地方\nNext:\n# 下一条指令\n# ...\nFar:\n# 需要跳转到的指令J-指令格式J指令只有两个域，其范围和名字如下：可以看出，opcode依旧在同一个地方，并且地址范围高达26位（左移两位是28位），已经很大了。\n\n还想跳得更远？\njr指令按照寄存器里面的值跳转，理论上可以跳转32位（左移是34位）的地址，也就是4GB（bytes）。但是jr是R型指令\n\n（伪）绝对地址寻址基本就是J型指令的寻址方式：\n\nPC的高四位来自当前指令的高四位\nPC的低28位用来寻址，也就是J型指令的instr_index的26位左移两位得到的。\n\n这么来看的话，目的地址和当前指令必须位于同一个区段，也就是说，地址转写成16进制后第一位数必须一样，因此j的转移范围就是256MB，确实很大，但是不是最大。\n\n\n\n\n\n\n区段的一种理解\n个人理解，区段就是主存中地址十六进制第一位相同的一片区域。\n\n\n小结\n现代计算机都是程序存储型的\n指令和数据都存在主存里面\n读取指令与读取数据完全可以使用相同的硬件机制、\n指令与数据位于不同区域\n通过PC读取的“32位01串”都被CPU当做指令\n通过Load/Store指令读写的“32位01串”都被CPU当做数据\n\n\n\n\n三型指令：I/J/R\nB类指令使用PC相对寻址，J指令使用（伪）绝对地址寻址\n\n\n附：手动汇编机器码步骤\n\n标识出指令类型（R/I/J）\n标识出正确的域\n用10进制表示各个域的值\n把各个域的10进制转换为2进制\n用16进制表示整个机器码\n\n\n\n\n附：手动反汇编机器码步骤\n\n用2进制表示指令\n根据opcode标识出指令类型（R/I/J）\n用10进制表示各个域的值\n用标识符表示各域，并添加相应的标号\n用汇编格式书写代码\n将汇编代码翻译为C\n\n\n\n","slug":"buaa-co-pre-7","date":"2024-08-08T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理,MIPS,汇编","author_index":"大仓鼠"},{"id":"3a8b96be6df1404e93229a67455be352","title":"北航计组-预习6-机器语言2","content":"\n\n\n\n\n\n\n\n\nMIPS按照字节编址……给哥们记住了，不是bit，是byte！\n机器语言2不等式数学上我们有四个不等关系：   \n但是在MIPS里面，我们只需要一条指令（配合beq bne $0）就可以实现这四种关系。\n小于指令Set on Less Than，即slt，用法和其他指令也差不多，即slt dst,src1,src2，当的时候，就会往dst写入1，否则写入0。\n其他符号的实现以下a均存在$s1里面，b均存在$s2里面：\n实现小于cif(a &lt; b){\n    /* then */\n}asmslt   $t0, $s1, $s2\nbne   $t0, $0, then实现大于等于cif(a &gt;= b){\n    /* then */\n}asmslt   $t0, $s1, $s2\nbeq   $t0, $0, then实现大于cif(a &gt; b){\n    /* then */\n}asmslt   $t0, $s2, $s1\nbne   $t0, $0, then实现小于等于cif(a &lt;= b){\n    /* then */\n}asmslt   $t0, $s2, $s1\nbeq   $t0, $0, then\n\n\n\n\n\n提示\n总结一下，先把带等于符号的取个反，小调等于号之后看哪一边需要小，需要小的一侧在slt指令里面放在src1的位置，之后根据之前是否取过反，第二个指令默认bne，取反就是beq。不过这都看个人喜好，怎么用还是随你。\n\nslt的变形\nsltu，即无符号数比较。sltu dst,src1,src2\nslti，即和立即数比较。slti dst,src,imm\nsltiu，即和立即数进行无符号比较。sltiu dst,src,imm\n\n\n一些题外话\n在MIPS里面signed和unsigned的意思很多样，但是万变不离其宗：\n\n符号位拓展：\nlb要拓展，lbu不拓展。\n\n\n溢出：\nadd sub addi mult div都要检测，而这几个指令后面加上u（即addu等）就不检测。\n\n\n符号数：\nslt slti符号数比较，sltu sltiu是无符号数比较。\n\n\n\n\n\n伪指令MIPS里面定义了一组伪指令，使得程序更加容易编写：\n\n伪指令并不是真正的指令\n伪指令只是为了增加可读性\n伪指令终究会被转换为真正的指令\n\n常用的伪指令\nMove\nmove dst, src，把src赋值给dst。\n\n\nLoad Address\nla dst, label，加载label对应的地址给dst。\n\n\nLoad Immediate\nli dst, imm，加载一个32位立即数给dst。\n\n\n\n\n\n\n\n\n\n如果你没懂为什么label是地址\n在汇编里面，我姑且把每一行对应的指令理解成这行所在的端被移动至某个cpu寻址寻的到的地方开始运行，而标号标定的就是这一行（或者最近的下一行）对应的地址，这个地址是由端的基地址加上偏移得到的，从而j或者beq bne之类的指令可以实现跳转。\n\n汇编寄存器由于伪指令的存在，许多伪指令的实现都需要多条真实指令，并且可能需要至多一个中间寄存器来传递数据，MIPS保留了$at，也就是$1作为汇编器专用的寄存器，其他程序不应该再去专门使用这个$at寄存器。\nTAL和MAL\nTAL：True Assembly Language\n真实的指令，计算机可以理解与执行。\n\n\nMAL：MIPS Assembly Language\n除了TAL的部分，还包含伪指令，每条MAL对应一条或者多条TAL指令。\n\n\n\n由此可见，\n实现函数一般步骤\n调用者把参数放置在某个地方以便函数能访问（$a0~`$a3`）\n调用者转移控制给被调用的函数（jal）\n函数获取局部变量对应的空间\n函数执行具体功能\n函数把返回值放置在某个地方，然后恢复使用的资源（$v0~`$v1`）\n返回控制给调用者\n\n函数相关寄存器我们尽量用寄存器，毕竟主存比较慢，因此需要几个寄存器专门用于传递参数。\n\n传递参数进入的寄存器：$s4-$s7这四个，分别被命名为$a0-$a3\n返回值的寄存器：$s2和$s3，名字叫做$v0和$v1\n返回地址寄存器：用来保存调用者的地址，是$s31，叫做$ra\n\n函数调用指令\nJump and Link：jal\n用法：jal label\n把jal的下一条指令保存在$ra，之后跳转到label\n一般用于调用函数\n\n\nJump Register：jr\n用法：jr src\n无条件跳转到src寄存器保存的地址，一般我们就用$ra\n一般用于从函数返回\n\n\n\nPC寄存器Program Counter是一个特殊寄存器，保存的是当前正在进行的指令的地址。\n\n\n\n\n\n\n提示\n\nPC寄存器是冯氏体系结构计算机的关键环节。\nMIPS里面PC对于程序员不可访问，但是jal指令可以访问。\njal保存到$ra寄存器的是，而不是本身，不然jr跳回来的时候又到了jal了，形成死循环。\n\n\n\n函数调用示例c...\nc = sum(a, b);\n...\n\nint sum(int x, int y){\n    return x + y;\n}asm# a-&gt;$s0 b-&gt;$s1 c-&gt;$s2\n...\n1000  addi  $a0, $s0, 0   # x = a\n1004  addi  $a1, $s1, 0   # y = b\n1008  jal   sum\n1012  addi  $a2, $v0, 0   # c = sum(a,b)\n...\n\n...\n2000  sum: add  $v0, $a0, $a1   # $v0 = x + y\n2004  jr  $ra                   # return $v0\n...保存和恢复寄存器原因由于寄存器很少，只用这点寄存器来编写程序属实是巧妇难为无米之炊，并且由于你只有一个$ra，如果出现了函数的嵌套调用，这个寄存器会被新的调用覆盖，导致无法跳转回最初的调用者，因此我们必须像个办法来保存寄存器到某个地方。\n\n\n\n\n\n\n提示\n寄存器保存在栈里面！\n\n因此我们保留了一个寄存器，对应$29，名字叫做$sp，即栈指针寄存器，指向栈的底端。（stack pointer）\n主存分配的基本方案stack frame即栈帧，实际上就是把$sp朝地址0方向移动之后得到的空间，并且由于栈帧容量是按照byte字节（=8bit）来算的，因此其容量就等于需要保存到寄存器数量乘以四（每个寄存器4个bytes）。当你移动了栈底指针后，就可以用这个寄存器加上偏移量的方式来表示你所需的保存过的寄存器了。\n\n\n\n\n\n\n提示\n你可能注意到，这里的表示方法类似于从主存里面取数据的方法，实际上栈就是保存在主存里面的，当然表示方法也一样。\n以及，虽然看起来空间无穷大，但是实际上还是有限的，这也是为什么你在c语言里面递归调用次数太多的时候会爆栈。\n\n当然，由于偏移量都是你自己设置的，入栈之后一定记得及时出栈，并且恢复栈底指针位置，不然后面偏移量都算不清楚。\n多重调用函数示例cint sumSquare(int x, int y){\n    return mult(x, x) + y;\n}asmsumSquare:\n    addi    $sp, $sp, -8    # 移动栈底往下8个字节\n    sw      $ra, 4($sp)     # 保存返回地址寄存器\n    sw      $a1, 0($sp)     # 保存y变量\n    move    $a1, $a0        # 传入mult的第二个参数设置为x\n    jal     mult            # 调用mult，此时$ra保存了下一行指令\n    lw      $a1, 0($sp)     # 取回y变量\n    add     $v0, $v0, $a1   # 计算mult(x,x)+y并保存到返回值里面\n    lw      $ra, 4($sp)     # 取回返回地址寄存器\n    addi    $sp, $sp, 8     # 栈底上移恢复原位\n    jr      $ra             # 返回原调用者\nmult:\n    mult    $a0, $a1        # 乘法运算，ao和a1都是x\n    mflo    $v0             # 低32位传回去，高32位先不管了……\n    jr      $ra             # 返回调用者sumSquare函数的架构我们上面已经了解了如何嵌套调用，因此我们可以看到一个函数如何构成的：\nasm############ 施法前摇 ############\nfunc_label:\n    addi    $sp, $sp, -framesize    # 下移栈底\n    sw      $ra, [framesize-4]($sp) # $ra保存到新区域的顶部\n    # 保存其他传入的参数之类的（比如$s0-$s7）\n\n############ 施法进行 ############\n    # jal调用其他函数\n    # 或者函数具体内容\n\n############ 施法后摇 ############\n    # 取回其他保存的参数\n    lw      $ra, [framesize-4]($sp) # 取回$ra\n    addi    $sp, $sp, framesize     # 恢复栈底\n    jr      $ra                     # 调用结束\n\n\n\n\n\n超过两重嵌套？\n有人可能会有疑问，欸你这万一不止两重嵌套呢，那栈底怎么移动啊，不是只有一个栈底吗？\n其实确实只有这一个（暂时），但是你也可以发现，我们每次调用函数需要移动栈底的时候，最后都移动回原位了的，因此对于每一层的函数，其栈底永远是同一个位置，它不会知道它调用的函数怎么动的栈底，因为对于它本身来说栈底在jal前后就没动过。\n\n局部变量和数组由于寄存器只有32个，因此编译器绝大多数情况下不可能把函数需要的所有局部变量都分配在寄存器，因此我们还是需要移动栈底来保存局部变量。\n图中比我们之前的代码似乎多保存了程序变量寄存器$s0到$s7，临时寄存器以及一些传入传出参数寄存器，其实只要用过的保存一遍就好了，和保存$ra没啥区别，因为$ra是每次jal调用的时候必须用到寄存器，所以至少得保存一个$ra。\n函数调用约定寄存器的保护其实我们上文已经提到过寄存器保护的问题了，保存-调用-恢复的这个过程其实就是寄存器的保护动作，只是对于不同寄存器的保护需求和细节不一样：可见分为强保护和弱保护，也比较显而易见的是强保护对于一整个函数来说都保护了，而弱保护是对于其调用的子函数来说保护了一下，不过我更喜欢叫做前者是被调用者保护，而后者叫做调用者保护，可能比较直观一些。\n保护机制的代码如下：强保护（被调用者）\nasmfunc_label:\n    addiu   $sp, $sp, -framesize    # 分配栈帧\n    sw      $ra, [framesize-4]($sp) # 保存$ra\n    sw      $s0, [framesize-8]($sp) # 保存s0-s7，下略\n    # ...\n    sw      $s7, 0($sp)\n\n    # 使用$s0~$s7\n    # 调用其他子函数\n\n    lw      $s7, 0($sp)             # 取回$s7~$s0，下略\n    # ...\n    lw      $s0, [framesize-8]($sp)\n    lw      $ra, [framesize-4]($sp) # 取回$ra\n    addiu   $sp, $sp, framesize     # 回收栈帧\n    jr      $ra                     # 返回弱保护（调用者）：\nasmfunc_label:\n\n    # 当前函数其他代码\n\n    addiu   $sp, $sp, -framesize    # 分配栈帧\n    sw      $t0, [framesize-8]($sp) # 保存t0-t7，下略\n    # ...\n    sw      $t7, 0($sp)\n\n    jal     child_func              # \n\n    lw      $t7, 0($sp)             # 取回$t7~$t0，下略\n    # ...\n    lw      $t0, [framesize-8]($sp)\n    lw      $ra, [framesize-4]($sp) # 取回$ra\n    addiu   $sp, $sp, framesize     # 回收栈帧\n\n    # 当前函数其他代码\n\n    jr      $ra                     # 返回\n\n\n\n\n\n提示\n$t0等临时寄存器可以不保护，只需要保证子函数不改变这个寄存器就行。\n但是$s0等程序员变量寄存器，如果一个函数使用了这些，就必须在进入和退出函数的时候分别保存恢复。\n\n小结\nbeq和slt可以实现各种比较（还有bne）\n伪指令增加易读性，但是可能不止对应一条真实指令，可能多条\n函数调用与返回（以及栈）\n\n","slug":"buaa-co-pre-6","date":"2024-08-06T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理,MIPS,汇编","author_index":"大仓鼠"},{"id":"8a3d05455b8690208682c71c22ab04dc","title":"北航计组-预习5-机器语言1","content":"机器语言1机器语言概述从代码到运行主要分为五个步骤：编译-汇编-存储-加载-运行。也就是从程序编译成汇编程序，再从汇编变成机器码，之后存到硬盘内，加载到主存储器中，最后交给CPU运行。\n编译编译器把高级语言（比如C语言）转化为汇编代码的过程。\n\n高级语言：适合人类书写和阅读\n汇编代码：稍微接近CPU理解和执行的语言（但是并非直接理解）\n\n通过编译可以把像这样的c语言代码：\ncwhile(1)\n    if(*p){\n        *q = *p;\n        p++;\n        q++;\n    }\n    else\n        break;翻译成这样的汇编代码：\nasmLoop_Start:\n    lbu     $t1, 0($s1)\n    sb      $t1, 0($s2)\n    addiu   $s1, $s1, 1\n    addiu   $s2, $s2, 1\n    beq     $t1, $0, Loop_End\n    j       Loop_Start\nLoop_End:汇编为了让CPU运行程序，还需要一次将汇编代码转换成机器码（也就是0101的串）的转换。区别如下：\n\n汇编程序：每行都是一条机器指令\n机器指令：由一组二进制01串组成，是CPU可以理解与执行的。\n\n存储C程序被编译为一组CPU指令后，就以文件方式被存储在硬盘中，其实就是二进制存储的。\n加载从硬盘读盘到内存里面，也就是主存储器，加载过程中指令和数据分开载入，分别在内存中的不同位置：\n\n代码段：存储CPU指令\n数据段：存储数据\n\n运行CPU运行程序无非就是如下的一个循环：\n\n读取指令：从内存代码段读取一条指令\n分析指令：分析指令功能\n执行指令：控制内部功能并执行操作\n\n\n\n\n\n\n\n\n\n\n对于RISC来说，只有读写主存的指令能够传输数据，下文会提到\n指令集如果说指令是CPU懂的单词，那么指令集ISA就是CPU理解的全部单词的集合\n\n如果只有一种ISA：可以很好的利用公共软件，如编译器、操作系统等\n如果有很多种不同的：不同的指令集有不同的设计平衡性考虑，有更适用的ISA\n\nRISCReduced Instruction Set Computing (RISC)\n\n加速大概率事件\n便于设计，电路频率更高\n简单功能交给硬件，复杂功能交给软件\n\n设计原则\n指导思想：CPU越简单性能越高\n设计目标：减少指令数量，去除复杂指令\n基本策略：\n指令定长：所有指令都占用32位（1个字），降低了从存储器中读取指令的复杂度\n简化指令寻址模式：以基地址+偏移为主，降低了从主存中读取操作数的复杂度\nISA的指令不仅数量少，而且简单，降低了指令执行的复杂度\n只有load与store两类指令能够访存\n把复杂留给编译，即编译器将高层语言复杂语句转换为若干简单的汇编指令\n\n\n\n\n\n\n\n\n\n\n\n\n我们选择学习MIPS是因为MIPS是RISC的典型代表，并且是真正的工业CPU\n寄存器计算机硬件的操作数对于c语言来说，变量的数量上限只被内存大小卡了，而且我们一般不考虑内存限制（除非是打acm……）对于ISA来说，有一组数量有限的而且一般是固定的操作数，叫做寄存器。\n\n\n\n\n\n\n\n\n\n小声bb：我姑且把寄存器理解成某种存数字的变量，后面有问题再回来改\n\n寄存器内置于CPU，因此访问速度很快（&lt;1ns)\n寄存器也因此数量少\n\n计算机中的时间单位\n\n\n时间单位\n\n\n\n\n\n\n\n全称\nmillisecond\nmicrosecond\nnanosecond\npicosecond\n\n\n中文名\n毫秒\n微妙\n纳秒\n皮秒\n\n\n换算\n\n\n\n\n\n\n频率等级\nKHz（千）\nMHz（兆）\nGHz（吉）\nTHz（太）\n\n\nMIPS的寄存器有且仅有32个寄存器，每个的宽度都是32位。\n\n\n\n\n\n\n说明\nPPT原文说寄存器没有类型（即无正负）实际上不太对，因为寄存器中只是一个32位的串，具体怎么解释仅取决于指令，而非“无正负”\n\n寄存器数量是均衡设计深思熟虑后的考虑：\n\n数量少：结构简单，速度快，能够存储在CPU内的数据少\n数量多：结构复杂，速度慢，能够存储在CPU内的数据多\n\n\n\n\n\n\n\n\n\n\n思考题：64位太占空间，16位精度或者范围不够用\n寄存器编号：0-31寄存器的表示：$x 其中x为0到31的数字，即从$0到$31寄存器是有名字的：\n\n程序员变量寄存器一般用$s0到$s7命名，对应寄存器编号为$16到$23\n临时变量寄存器是$t0到$t7（对应$08到$15），和$t8、$t9（对应$24和$25）\n\n这样可以稍微提高一点汇编代码的可读性……也许吧\n指令和立即数MIPS指令指令格式asmop dst, src1, src2其中：\n\nop：指令的功能\ndst：保存结果的寄存器\nsrc1：第一个操作数\nsrc2：第二个操作数\n\n如此，这种固定的格式既有助于人理解与编写，也可以使得硬件变得简单。\n\n\n\n\n\n\n提示\n硬件越简单，延迟越小，时钟频率越高。\n\n指令的特点\n每条指令有且仅有一个操作\n每行有且仅有一个指令\n和C语言的运算紧密相关（其实这个该算C语言的特点了吧）\n一行C代码会对应多条指令\n\n例子假如有三个变量a b c分别存在三个寄存器$s1 $s2 $s3之中，以下c语言代码可以写成MIPS的汇编形式：\nca = b + c;\na = b - c;asmadd $s1, $s2, $s3   # a = b + c\nsub $s1, $s2, $s3   # a = b - c那如果一行c语言代码有多个运算呢？那就得折磨编译器了为了保证每行只有一条指令，一种对于x = (a + b) - (c + d)的可能实现如下：\nasm# 假设x,a,b,c,d分别对应s0-s4这五个寄存器\nadd $t1, $s1, $s2   # t1 = a + b\nadd $t2, $s3, $s4   # t2 = c + d\nsub $s0, $t1, $t2   # x = t1 - t2我们在这之中使用了两个临时变量寄存器。\n\n欸！我也有一道自制的小题💡🤓👆\n其实编译器能够做到的相比直接翻译代码来说会更多一些，你可以尝试一下不使用临时寄存器来把结果算出来。\n\n0号寄存器由于成都人太多数字0在程序中使用频率很高，为此MIPS专门为其分配了一个只读寄存器$0，或者用$zero表示，这个寄存器读出来一定是0，并且写入的数据被丢弃。\n比如我此时需要给变量c（存在$s3内）赋值为0，并且把b（存在$s2内）的值赋给a（存在$s1内）：\nasmadd $s3, $0, $0   # c = 0\nadd $s1, $s2, $0  # a = b立即数\n\n\n\n\n\n\n\n\n也许叫immediate number?\n指令中的常量数值就是立即数，对于立即数来说，加法的汇编操作不太一样(addi)：\nasm# 语法是：op dst, src, imm 其中imm是立即数\naddi $s1, $s2, 5  # a = b + 5\naddi $s3, $s3, 1  # c++数据传输指令这里的数据传输指的是寄存器与主存储器之间的数据交换。\n主存单元寄存器？主存？❌寄存器仅有32个，有限的寄存器存不完大量变量，比如我写sb代码的时候10e8大数组、高维矩阵等等……\n✔所以我们需要主存来解决问题，大部分变量存在主存中，需要用的时候加载到寄存器中。\n主存的抽象模型主存可以被抽象成一个数组，其中存储数据单位为byte（记住了，这玩意是8bit，俩Hex），而存储数据位置就是地址，类似数组下标。\n\n如图的4GB（这里的B是byte哈，不是bit）主存，有4G个存储单元，也就是个存储单元。因此对应的地址为0x00000000到0xFFFFFFFF，地址位数为32位。\n\n\n\n\n\n\n提醒\n注意区分地址的位数和存储的位数，此处地址位数是32位，但是一个存储单元里面只有1byte，也就是8位。\n\n\nCPU字长\ncpu的字长指的是cpu一条指令可以计算的数据的宽度，比如MIPS字长32位，也就是单条MIPS可以计算的数据就是32位。有人问那long long这种数据类型怎么实现的，别急，多条指令照样可以实现，但是这样也损失了一些性能罢了。\n\n如同上文所述，我们一般把CPU抽象成一个二维数组，其中每一行的长度就是CPU字长。（这里仅是一种模拟而已，不要太当真）那么字地址就是某字第0列的单元对应的字节的地址。\n地址的表示方式两种方法\n绝对地址：\n主存单元的地址直接用具体数值表示\n比如下图中黄色单元地址为P = 0xFFFFFFF9\n\n\n相对地址：\n采用“基地址+偏移”的形式表示\n比如以B1为基地址，那么P的地址就是P = B1 + 1\n\n\n\n基地址+偏移的优点\n一致：与数据结构的访问方式一致，比如数组就是基地址+偏移。\n统一：可以用固定base与不同的offset得到任意地址。\n灵活：不同的base和offset可以对应同一个地址，编程更加灵活。\n\n数据传输指令语法asmop reg, off(base)\nreg：写入或读出的寄存器\nbase：存储基地址的寄存器（实际上base被视作无符号数）\noff：以byte为单位的偏移量，可正可负\n\n因此读写的存储单元的实际地址为base + off\nlw/sw指令\nlw：Load Word\n读取地址为base + off的一个字，然后写入reg\n\n\nsw：Store Word\n读取reg，写入base + off\n\n\n\n比如说我们需要汇编如下的c语言代码\ncint A[100];\nA[10] = A[3] + a;假设指针*A存储的地址在寄存器$s3里面，而a变量对应寄存器$s0。\n\n\n\n\n\n\n\n注意\nA[10]在c语言代表A数组的下标为10的位置的值，但是实际上这是一个语法糖，A[10]其实本质上是*(A+10)，其中(A+10)就是int类型指针变量A的内容（也就是一个地址）往后偏移10个int类型（或者其他类型）的长度后对应的地址，那么*(A+10)就是该地址对应的int（或其它类型）的指针指向的长度为int（或其它类型）的内容（也就是一个存到这里的数），这句话可能有点绕，但是多理解一下指针总是好事情不是吗？\n这个时候你去理解为什么A[]可以存在寄存器中就清楚多了，因为A本质上就是一个字长的无符号数（代表地址）（注意区分一下*A代表的才是这个地址内存的值，亦即A[0]），这个无符号数（地址）就是寄存器$s3的内容；同理变量a也有地址&amp;a，这个地址就是寄存器$s0的内容。\n\n\n\n\n\n\n\n\n\n\n因此我也喜欢把寄存器理解成对地址的操作。\n闲话少说，我们通过lw和sw实现汇编如下：\nasmlw $t0, 12($s3)     # $t0 = A[3]\nadd $t0, $t0, $s0   # $t0 = $t0 + a\nsw $t0, 40($s3)     # A[10] = $t0\n\n\n\n\n\n\n特别注意\n如下写法有误\nasmlw $t0, 12($s3) \nadd $t0, $t0, $s0\nlw 40($s3), $t0其原因是必须严格遵循lw和rw的格式，也就是op reg, off(base)，如果后面能换，那我问你为什么会有lw和sw俩指令呢？\n\n主存单元使用的限制MIPS不支持主存单元参与运算，主存单元只能和寄存器进行数据交换，这样便于设计流水线CPU。\n\n\n\n\n\n\n\n特别注意\n以下均错误：\nasmadd $t0, $s1, 0($s2)\nsub $t0, 0($s2), 12都错在用了主存单元里面的东西。\n\n\n\n\n\n\n\nMIPS支持的运算\n寄存器——寄存器：寄存器与寄存器运算，结果写入寄存器。寄存器——立即数：寄存器与立即数运算，结果写入寄存器。\n\nlb/sb指令我们望文生义一下，其实和lw/sw差不多，这俩指令从word变成了byte而已，区别在于，如果涉及主存的话，偏移量可以不为4的倍数。\n\n\n\n\n\n\n\n\n\n我仔细想了一下，其实lw和sw也可以不为4的倍数，只是会写到后面的内存里面罢了吧，等后面再来纠错吧。\n纠错：为了提高运行效率，lw必须得以四的倍数对齐，这样可以避免跨缓存行访问数据，提高性能。\n用法：\nasmop reg, off(base)其实和lw和sw一样，但是需要注意lb在写入寄存器的时候会进行符号位拓展，直接补满高24位，虽然补了，但是作用仅仅是保留符号位，当你调用sb的时候还是只会写入后八位。\n\n\n\n\n\n\n还有个命令\nlbu这个进行的操作就是直接写8个bit，也就是一个byte到寄存器里面，不补符号位（也就是全部补0）。\n\n指令汇总\n字操作：lw sw\n半字操作：lh lhu sh\n字节操作：lb lbu sb\n\n大小印第安（大端小端）\n大印第安：最高有效字节在字内的最低地址\n小印第安：最高有效字节在字内的最高地址\n\n\n\n\n\n\n\n\n\n\n我们这一般用小印第安，低对低，高对高。\n判断指令MIPS一般用标号机制实现转移：\n\nMIPS不像c一样有if/while之类的语句块\n每条指令都对应一个32位（不一定）的地址（一个字）\n为了可读性，一般用字符串加冒号的形式作为标号，标记其后指令的地址：比如ForBegin:\n汇编通过跳转机制到标号处实现转移（类似c语言的goto）\n\n决策指令三个转移指令\nBranch If Equal：即beq，相等的时候转移：\nbeq reg1, reg2, label\n当reg1的值和reg2的值相等的时候，跳转到label处继续运行。\n\n\nBranch If Not Equal：即bne，不相等的时候转移：\nbne reg1, reg2, label\n当reg1和reg2的值不等的时候跳转。\n\n\nJump：即j，无条件转移：\nj label\n无条件，直接跳转，类似c语言的goto\n\n\n\n\n\n\n\n\n\n提示\nB类分支指令的label可以直接用立即数，因为label本来就是立即数，编译的时候“替换”。\n\nif-else的汇编构造方式c语言代码：\ncif(i == j){\n    a = b; // then\n}else{\n    a = -b; // else\n}汇编（beq）：\nasm# i-&gt;$s0, j-&gt;$s1\n# a-&gt;$s2, b-&gt;$s3\nbeq $s0, $s1, then\nsub $s2, $0, $s3\nj end\nthen:\nadd $s2, $s3, $0\nend:汇编（bne）:\nasmbne $s0, $s1, else\nadd $s2, $s3, $0\nj end\nelse:\nsub $s2, $0, $s3\nend:switch-case的构造方式大多数高级程序设计语言都有switch-case结构，我们在MIPS里面可以如下构造：C语言：\ncswitch(){\n    case 条件1:\n        语句块1;\n    case 条件2:\n        语句块2;\n    ...\n    case 条件N:\n        语句块N;\n    default:\n        语句块default;\n}MIPS汇编：\nasm    b类, 条件1, Case1\n    b类, 条件2, Case2\n    ...\n    b类, 条件N, CaseN\nDefault:\n    语句块default\n    j SwitchEnd\nCase1:\n    语句块1\n    j SwitchEnd\nCase2:\n    语句块2\n    j SwitchEnd\n    ...\nCaseN:\n    语句块N\n    j SwitchEnd\nSwitchEnd:\n指令类别\n\nR类：一般用于寄存器-寄存器操作。\nI类：一般用于立即数访问和load操作。\nS类：用于访存store操作。\nB类：用于条件跳转操作。\nJ类：用于无条件操作。\n\n\n\n\n\n\n\n\n\n\n注意，其实我们课里面只分为R/I/J三型，与这里的类区分一下\n\n\n其他分支指令与0比较的分支指令(即bxxz类指令)\n\nblez：小于等于0转移\nbltz：小于0转移\nbgez：大于等于0转移\nbgtz：大于0转移\n\n以上bxxz类指令格式均为\ntxtop rs, label\n\n\n\n\n\n提示\n由于固定和0比较大小，所以就不需要劳烦$0寄存器了。\n\n循环指令？\n\n\n\n\n\n\n\n\nMIPS只需要根据条件转移就好啦！\n比如我们构建一个复制字符串的while循环，从p数组复制到q数组，一种c语言的神金实现如下：\ncchar *p, *q;\nwhile((*q++ = *p++) != EOF);\n如果你不懂这段神金的话……\n\nc语言中，赋值表达式的返回值是左值。\n指针++作用是移动一个类型的空间，++在后表示这一行执行完后再自增。\n\n\n\n汇编后代码如下：\nasm# p-&gt;$s0, q-&gt;$s1\nLoop:\n    lb $t0, 0($s0)\n    sb $t0, 0($s1)\n    addi $s0, $s0, 1\n    addi $s1, $s1, 1\n    bne $t0, $0, Loop运算指令MIPS为高级程序设计语言的加减乘除等算术运算提供了相应的指令，并且可以分为“寄存器-寄存器（R-R）”和“寄存器-立即数（R-I）”两类。\n加减法指令汇总加法有四条：add addu addi addiu减法只有两条：sub subu\n\n\n\n\n\n\n没有subi/subiu的原因\n加上相反数就是减，所以可以用addi``addiu直接实现，多用多浪费嘛。\n\n溢出MIPS会检测溢出，并且溢出时产生错误，当指令有unsigned关键字的时候忽略溢出。\nasm# $s0=0x80000000（即最小的负数）, $s1=0x1\nadd\t   \t$t0, $s0, $s0\t# 溢出错误\naddu\t$t1, $s0, $s0\t# $t1 = 0\naddi\t$t2, $s0, -1\t# 溢出错误\naddiu\t$t3, $s0, -1\t# $t3 = 0x7FFFFFFF\nsub\t\t$t4, $s0, $s1\t# 溢出错误\nsubu\t$t5, $s0, $s1\t# $t5 = 0x7FFFFFFF乘除法HI/LO寄存器注意，乘除法指令中并不存在dst寄存器，因为结果单独存在HI和LO这俩特殊寄存器里面，并不属于之前的32个通用寄存器。有两条特殊的寄存器读指令：\n\nmove from HI：即从HI读取，写入到dst里面（mfhi dst）\nmove from LO：即从LO读取，写入到dst里面（mflo dst）\n\n乘除法指令\n乘法是mult src1,src2\n结果是，并且低32位保存在LO寄存器，高32位保存在HI寄存器\n\n\n除法是div src1,src2\n结果是，LO保存商，HI保存余数\n\n\n\n位运算按位计算我们依旧假设a-&gt;$s1, b-&gt;$s2, c-&gt;$s3，有如下位运算指令：同样的，也分为是否有立即数的两个版本。\n移位指令位移如果用立即数，那就只有0-31有效，如果用寄存器，那就只有第五位（视作无符号数）有效。\n方便记忆来说，s代表移位类指令，第二位l、r代表左右，第三位l代表逻辑（logical），a代表算数（arithmetic），v代表不用立即数，而是寄存器。\n\n\n\n\n\n\n提示\n左移只需要低位补0，所以不需要算术左移，没有意义，而算术右移是要补符号位的，所以得区分。\n\nasmaddi $t0, $0, -256 # $t0=0xFFFFFF00\nsll\t $s0, $t0, 3   # $s0=0xFFFFF800\nsrl  $s1, $t0, 8   # $s1=0x00FFFFFF\nsra\t $s2, $t0, 8   # $s2=0xFFFFFFFF\n\naddi $t1, $s0, -22 # $t1=0xFFFFF7EA 低五位01010即十进制的10\nsllv $s3, $t0, $t1 # $s3=0xFFFC0000","slug":"buaa-co-pre-5","date":"2024-07-31T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理,MIPS,汇编","author_index":"大仓鼠"},{"id":"0d519e95d32b3bfd8b6aa80ad86d4aac","title":"北航计组-预习3-时序电路","content":"\n\n\n\n\n\n\n\n\n一些写在前面的话：我打算还是少一些照抄ppt的内容，以我自己的理解为准，可能理解略有偏差，但是也算是一种不一样的理解一个知识点的方式，所以也是有可取之处的，有问题我也可以及时修改，后面复习也可以参考，大概就这样吧。\n时序电路双稳态电路构成方式一般是由两个反相器构成，这样的作用就在于在不需要外部维持的情况下，稳态电路可以自行维持其一开始的状态。\n\n\n\n\n\n\n提示\n可能有朋友会疑惑，说好的能量守恒呢，你这不可能没有能量损失吧，那我哪里来的高电平啊？实际上在这种电路中，反相器实际上要接电源的，也就是能够提供能量，所以不需要钻牛角尖说这是一个“独立”的电路了。\n\n示意图和真值表ppt中有a和b两张图，实际上只是电路扭了扭而已，二者完全一致。\n\n\n\n\n\n\n\n\n0\n1\n\n\n1\n0\n\n\n需要注意的是，这个真值表看起来并不像是一个正经的真值表，相比我们之前认识的那些真值表，似乎没有能够“主动”变化的变量，但是话说回来这个真值表其实没有问题，只是因为我们不存在随时间变化的问题，所以我们只是枚举了所有（两种）可能的情况，后续我们可能会遇上和历史状态相关的真值表，下午将会提到。\nRS锁存器构成方式和双稳态差不多，把非门换成了或非门，依旧是采用了交叉反馈的方式，连线如下图。\n可能又有朋友疑惑，说欸你这个和以及另一对难道不是同一个东西吗，咋有俩名字。其实确实是同一个东西，只是为了之后写真值表的时候方便分析才这样取了个名字而已，无需在意。\n真值表和特性此处真值表与上一时刻状态可能有关，我们会分为两个部分，前三条为外部输入能够完全确定的部分，后两条为外部输入需要与上一时刻的值一同决定的部分：\n\n\n\nNo.\nS\nR\n\n\n\n\n\n\n1\n0\n1\n-\n0\n1\n\n\n2\n1\n0\n-\n1\n0\n\n\n3\n1\n1\n-\n0\n0\n\n\n4\n0\n0\n1\n1\n0\n\n\n5\n0\n0\n0\n0\n1\n\n\n简单的来说，在S（set），和R（reset）为1、0或者0、1的时候，S取多少，Q就被设置为多少；而S和R同为0的时候我们可以理解成保持，这时候Q的值维持前一时刻的状态。\n一般来说，我们把S取1，Q取0的时候叫做“置位”；S取0，Q取1的情况叫做“清除”。\n\n\n\n\n\n\n\n注意\nS和R不能同时取1，真值表中第三条可以看出，会导致当前时刻和同时变为0，按理说也不是不行，但是我们分析会发现，S和R毕竟是人为控制的，大部分时候会在保持的状态，也就是二者同为0，这时候输出端两个0反馈到输入端，N1和N2两个或非门输出为1，也就是输出突然反转为1了，而这时输出又一次反馈给输入，两个或非门输出变成0，又一次反转。也就是说，输出端在疯狂振荡，可能会导致损坏甚至更严重的问题。\n\nRS的局限性\n语义上来看，寄存器应该实现数据输入输出，但是RS锁存器实现的是置位和归零。PPT里面这么说的，我觉得有待商榷，因为输出端就可以实现数据输出，而输入端接一个非门就可以实现数据输入了，可能老师认为不能加东西吧\n从时序上看：RS不能实现对时间信号的响应，无法被协调操控。\n\nD锁存器结构和形式内部结构：其实就是我RS套壳辣！桀桀桀桀桀\n你要理解D锁存器也很简单，其实就是CLK信号作用到两个与门上面，CLK为0的时候就把与门堵死了，CLK为1就导通给D信号用；而D信号就像我之前说的那样，分成两股，其中一个加上非门，变成了R/S信号给到了RS锁存器，就是这么简单，而D锁存器的一个好处也在这里，完全避免了R和S同为1的非法情况产生。\n真值表此处直接放上简化后的真值表：\n\n\n\nCLK\nD\n\n\n\n\n0\nX\n\n\n\n1\nD\nD\n\n\n局限性由于CLK为1的时候Q始终随D变化，ppt中提到的是没法完全对齐时钟，我觉得更好的说法是，D锁存器只是利用时钟信号做了一个开关，而并非对齐，真正的对齐还得是边沿对齐的方式。并且还有一点就行真实的信号是有抖动的，D信号的不稳定会导致输出的Q也具有相同的抖动，如果后面接了边缘对齐类型的东西的话就会出大问题。\nD寄存器\n\n\n\n\n\n\n\n\n我更喜欢叫“上升边沿触发的D锁存器”\n结构和形式其实是两个D锁存器的串联，加上了不一样的时钟信号，实现了一种隔离。\n真值表和特性信号特性其真值表其实和D锁存器差不多，但是CLK信号分边沿来写即可：\n\n\n\nCLK\nD\n\n\n\n\n↓\n-\n\n\n\n↑\nD\nD\n\n\n也就是说，CLK信号上升沿才会使得Q变化，并且变化为当前D的值。这就很好的避免了在D刚刚变化的时候产生的抖动等问题，也实现了真正的时钟同步。\n时间特性\n 建立时间，Setup Time，即D在边沿前所需要稳定的时间\n 保持时间，Hold Time，即D在边沿后所需要稳定的时间\n 输出延迟，CLK-to-Q delay，在边沿到Q产生变化的时间差\n\n\nD寄存器的拓展应用多路选择器MUX这个其实不是D寄存器，我们先认识一下MUX，这是后续的一个基础：\n作用：根据控制信号取值，让输出信号的取值为多个输入信号的某个取值。简而言之就是，选！\n\n真值表：\n\n\n\nS\n\n\nY\n\n\n\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n\n\n0\n1\n0\n0\n\n\n0\n1\n1\n1\n\n\n1\n0\n0\n0\n\n\n1\n0\n1\n0\n\n\n1\n1\n0\n1\n\n\n1\n1\n1\n1\n\n\n其表达式也不难写出：\n\n\n\n\n\n\n说明\n这里是一个二选一的MUX，以后还会遇上2的n次方选1的情况，这种情况下输入信号数当然是2的n次方，但是我们可以简单分析一下选择信号的数量，利用二进制无符号数可以发现，只需要n位0、1就可以达到选择的作用，所以只需要n个选择信号就能够实现选1的效果。\n\n带使能的D寄存器这其中就用到了二选一的MUX，上文已经提到过了。简而言之就是当EN信号为1的时候才有用，为0的时候就用当作输入，也就是屏蔽了D的信号。\n带同步清除的D寄存器利用一个与门，当reset信号为1的时候，经过一次非门变成0，使得与门输出强制变为0并且作为D寄存器的输入，也就是强制写入0的作用。当然，reset为0的时候，采用的就是原始的D输入啦。\n总结简单的时序电路入门，学习了RS和D锁存器，利用时钟边沿触发的寄存器也学了，引申了一些其他的D寄存器。\n我缺的JK寄存器谁给我补上啊啊啊啊啊，我的JK\n","slug":"buaa-co-pre-3","date":"2024-07-29T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理,时序电路","author_index":"大仓鼠"},{"id":"106042df361711128e93d1695c28edbf","title":"折腾笔记-hexo、Mathjax、Latex的奇妙bug","content":"前言从来没想过能有这种奇妙问题……\nbug复现我在写笔记的时候需要用到Latex写一些公式，前端用的Mathjax渲染，但是公式换行始终无法解决。\n按道理来说\\\\是可以起到换行的作用的，结果实际如下：\n代码latex\\begin{align*}\nD &amp;= (\\overline{AB})(A+\\bar{B}C) \\\\\n  &amp;= (\\bar{A}+\\bar{B})(A+\\bar{B}C) \\\\\n  &amp;= A\\bar{A}+\\bar{A}\\bar{B}C+A\\bar{B}+\\bar{B}\\bar{B}C \\\\\n  &amp;= (\\bar{A}+1)\\bar{B}C+A\\bar{B} \\\\\n  &amp;= \\bar{B}C+A\\bar{B} \\\\\n  &amp;= \\bar{B}(A+C)\n\\end{align*}现象\nbug原理和修复Mathjax其实不需要背锅，出问题的是markdown把\\\\转义成\\了，因此前端代码渲染出来的是\\的效果。所以我们需要把latex代码里面的\\\\全部替换成\\\\\\\\，由此就可以转义变成\\\\正确渲染了：\n代码latex\\begin{align*}\nD &amp;= (\\overline{AB})(A+\\bar{B}C) \\\\\\\\\n  &amp;= (\\bar{A}+\\bar{B})(A+\\bar{B}C) \\\\\\\\\n  &amp;= A\\bar{A}+\\bar{A}\\bar{B}C+A\\bar{B}+\\bar{B}\\bar{B}C \\\\\\\\\n  &amp;= (\\bar{A}+1)\\bar{B}C+A\\bar{B} \\\\\\\\\n  &amp;= \\bar{B}C+A\\bar{B} \\\\\\\\\n  &amp;= \\bar{B}(A+C)\n\\end{align*}现象\n","slug":"hexo-mathjax","date":"2024-07-28T16:00:00.000Z","categories_index":"折腾笔记,网页","tags_index":"hexo,Mathjax,Latex","author_index":"大仓鼠"},{"id":"98d48bfcc3d8d2c9c7bc42d4a7352b22","title":"北航计组-预习2-从门电路到运算","content":"门电路电路类型同步数字电路有两种类型：\n\n组合逻辑\n输出只是输入的函数，和历史状态无关\n如：加法器\n\n\n时序逻辑\n能够存储信息，也即是与历史状态有关\n如：寄存器\n\n\n\n逻辑门NOT真值表：\n\n\n\na\nc\n\n\n\n0\n1\n\n\n1\n0\n\n\nAND真值表：\n\n\n\na\nb\nc\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\nOR真值表：\n\n\n\na\nb\nc\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n1\n\n\nNAND真值表：\n\n\n\na\nb\nc\n\n\n\n0\n0\n1\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\nNOR真值表：\n\n\n\na\nb\nc\n\n\n\n0\n0\n1\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n0\n\n\nXOR真值表：\n\n\n\na\nb\nc\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n更复杂的真值表举个例子：三选二表决\n\n\n\na\nb\nc\ny\n\n\n\n0\n0\n0\n0\n\n\n0\n0\n1\n0\n\n\n0\n1\n0\n0\n\n\n0\n1\n1\n1\n\n\n1\n0\n0\n0\n\n\n1\n0\n1\n1\n\n\n1\n1\n0\n1\n\n\n1\n1\n1\n1\n\n\n真值表变成布尔表达式以下根据该真值表，变量为1的话就取变量名，反之取NOT变量名：\n\n\n\na\nb\nc\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\nSoP(积项求和)类似于主析取范式（？），把结果为1的最小项给析取了，即踩中一个最小项就为1。\n\nPoS(和项求积)类似于主和取范式，把结果为0的最大项合取，只有不踩中任何一个最大项才是1。\n\n布尔表达式化简基本定律其实就是离散数学那堆东西：其中最常用的就是分配律\n举个栗子对于这一个式子，电路如下：\n具体过程为：\n\n结果就是a与c的或，相比最初简单了不少。\n组合逻辑的转换大致如ppt上的图所示，除了真值表转电路图比较麻烦之外，其他的其实都很直观：\n电路化简\n遍历建立真值表，之后用SoP或者PoS化简\n写出电路对应表达式，对表达式化简\n\n第一种较为简单，不举例子了。对于第二种来说，化简和之前一样，此处举一个电路对应表达式的例子：\n从输入到输出，依次建立表达式子(标记在线边上)，但是，写式子的时候我觉得应该从输出往回看，因为只有最后那个最大：\n\n由此得知，可以电路化简为：\n卡诺图化简表达式\n\n\n\n\n\n\n\n\n本质：利用相邻项一次化简一个比如和\n步骤：\n\n构建卡诺图，其实就是一个方格，比如五变量的分为2和3，2变量方向有格，3变量方向格\n填1，比如四变量的SoP里面出现了这一项，那么ab（2变量）方向上对应10的格且cd方向上对应01、11的格得标注为1，即坐标为(10,01)(10,11)这俩。\n根据以下规则画圈：\n组内有效单元的个数必须是2的整数幂\n应该选择尽可能大的组\n注意4角的单元\n避免出现单个单元\n\n\n\n举个例子：根据画圈的不同可以化简为：\n\n运算一位加法器对于单独一位来说，加法需要“本位”和“进位”，分别为和，而上一位的进位是：\n\n\n\n\n\n\n\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n1\n0\n\n\n0\n1\n1\n0\n1\n\n\n1\n0\n0\n1\n0\n\n\n1\n0\n1\n0\n1\n\n\n1\n1\n0\n0\n1\n\n\n1\n1\n1\n1\n1\n\n\n对于和各自可以列出SoP形式的式子：\n\n串行加法器对于每个加法器来说，输入是本位的和，上一位的进位也是输入，而输出是本位的值和往下一位的进位，由此组成一个串：\n其中可以看出，第0位的进位为0，因为其之前并没有进位，根本没有数字。\n总结\n门电路：多种逻辑门的表示以及几种化简方法（卡诺图、规则化简）\n运算：构建一个串行加法器\n\n","slug":"buaa-co-pre-2","date":"2024-07-28T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理,数字电路","author_index":"大仓鼠"},{"id":"ee17b1d2d4f98e58465a0cc1225842a7","title":"北航计组-预习0-预习准备","content":"计组预习-Part0第一天预习就先看一下课程内容，我打算先从课程内容开始，整理一下预习的过程，然后按顺序预习，中途可以补一些题或者看一下教材，主要还是打算用往年课件作为第一次预习的资料，符合我个人习惯一些。\n课程组成目标反正就是学硬件、软硬件协同、设计硬件、从数电到MIPS到MIPS程序\n大概有的课\n概论一节\n组合、时序逻辑（似乎电电B讲过了）\n存储器、存储系统、方式\n指令、汇编\nMIPS不同的课会排在不同的时间，具体看到时候安排吧。\n\n学习内容\n基本原理\n硬件描述语言（HDL）\nVerilog\n软件工具：logisim\n软件工具：MARS\n软硬件调试\n\n预习安排大致上我应该每一讲都会写一次笔记，前面会附上本次课程的目标与内容，顺序上先学习理论课，实验课后续补上，中途我可能会自己穿插一些练习，不再赘述，参考网站我也会附上的。其他有些资源我会扔到OSS上面，有需要的可以看情况下载。\n课程安排应该是预备阶段week1-6，后续是任务阶段week7-17，我打算先把预备阶段准备好，后续P0-P8再说吧，先不急。\n一点疑惑似乎2022课件相比2018课件把存储部分都删了？\n","slug":"buaa-co-pre-0","date":"2024-07-26T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理","author_index":"大仓鼠"},{"id":"b8770cb77afe30b610a74e7f474f90fc","title":"北航计组-预习1-基本认识与数制","content":"基本认识计算机的基本认识发展过程\nENIAC；第一台数字式多用途计算机\n计算炮弹弹道（逃）\n\n\n大型机时代：20c50s-60s\n小型机时代：20c70s\nPC时代：20c80s-21c\n后PC时代：21c之后\n\n重大认识\n层次化表示与解释\n\n\n任何事物都可以表示为数字\n\n\n摩尔定律\n\n\n晶体管数量每两年翻倍\n\n\n局部性与存储层次\n并行性\n性能度量与改进\n\n计算机的应用与分类分类\nPC\n服务器\n服务器集群\n超级计算机\n嵌入式计算机（最大的计算机市场）\n\n计算机的基本硬件构成CPUCPU是计算机的最核心部件，其功能是能够执行由一组指令构成的程序。抽象为两个部分：数据通路、控制器\n\n数据通路：执行指令所需的计算与存储的功能部件集合\nPC：指向要执行的指令\nALU：完成各类计算，如加减乘除\n寄存器堆：临时性存储参与运算的数据以及运算结果\n\n\n控制器：根据指令控制数据通路的各个部件完成相应操作\n\n评价为：数据通路是干活的鼠鼠，控制器是指使干活的可恶猫猫。\n而对于现代主流CPU：通常包含cache、MMU，每个核心相当于过去的一个完整CPU\n主存储器也被称为内存，而CD、硬盘之类的东西叫做外存（辅存）\n早期内存只有几个K，现在动辄以G字节计数。\n计算机的层次结构一个完整的计算机系统，可以划分为硬件和软件两大部分。其中，两者之间的交互界面就是指令集：\n数制常见进制及其转换表示方法对于来说，它的值是：\n\n二进制每一位称之为一个bit。其基为{0,1}\n进制转换其实就是转换前的数一直除以转换后进制的进制数，之后取余数，从最低位到最高位，比如10转2进制：16、8、2进制的互转比较容易，因为刚好可以对应。\n常见术语\n字节byte\n由8个二进制位构成的一个元组，是目前计算机的数据单位\n\n\n字word\n根据计算机的不同而不同，可能是32位、64位等等\n\n\n最高有效位MSB\n最低有效位LSB\n最高有效字节MSB\n最低有效字节LSB\n高在左，低在右\n\n\n\n二进制加法步骤二进制加法与十进制加法原理类似，对应位相加就行，加到2就进位一个1即可：由于一个字的长度是有限制的，比如32位计算机最高位两个1相加，此时就会发生溢出（overflow），一般来说，CPU在溢出发生时，会通过称为异常（exception）的机制来报告这个错误。\n整数的二进制表示方法数字对于一个数字来说，其包含2部分内容:\n\n编码：就是数字本身，或者说是一种记号。例如007\n语义：编码所代表的概念的含义，是对编码的解释\n\n\n\n\n\n\n\n提示\n编码本身没有任何意义，编码只有被赋予语义后才有意义\n\n编码空间\n编码空间：有效编码的集合\n空间大小：有效编码的总数\n对于一个n位B进制数来说，其编码空间大小为\n\n\n\n\n\n\n\n\n\n提示\nQ：对于某个B进制来说，如何确定某个编码方案的编码位数？A：如果对象数量为N，则位数为\n\n二进制无符号数对于二进制无符号数如下：\n二进制符号数原码方案用最高位代表符号，0为正1为负，其余位数为绝对值，比如：\n\n\n\n\n\n\n\n\n\n注意\n\n存在两个0，即和\n有效编码被浪费\n硬件加法难以实现\n\n\n编码数值不连续\n并且在正负区域并非连续增大\n\n\n\n\n\n补码方案用最高位代表符号，0为正1为负，100…000是最小的负数，而111…111是-1\n\n\n\n\n\n\n特点\n\n只有一个0\n符号确定后，数值随编码增长而增长\n\n\n\n表示范围可以为-2147483648到2147483647\n对于一个的N位二进制补码代表的数，它的值为：\n\n\n\n\n\n\n\n小结\n\n现代计算机普遍采用\n使用最高位作为符号位\n负数区间比正数区间多一个数\n相反数计算方法：各位取反，然后加1\n\n\n\n浮点数的二进制表示方法浮点数格式每个浮点数都类似科学计数法可以表述为：\n其中M为尾数，B为基数，E为指数\n\n包含符号S，尾数、指数、基数，其中基数被省略了\n符号一位，0正1负\n指数八位，表示范围\n尾数23位，表示精度\n基数默认为2\n\n我们考虑到二进制尾数的第一位保证是1，如果不是的话说明指数取大了，那么为了优化，我们可以默认尾数最高位为1，这样就可以在尾数里面多一位有效的存储位了，只是计算的时候得补回来，我们以为例：\n此时尾数1.010001101110，我们优化成010001101110\n\n\n\n\n\n\n提示\n绝对值小于1的浮点数的二进制编码对应的数相比其大于1的数更大一些，因为其指数部分是负数，取补码的时候最高位为1，比指数为正的数字会更大一些。\n\n偏阶计数法本质上就是把编码用的指数变成真实指数（的二进制）加上十进制的127，即，此时就可以让对应最小的负指数（即0减去127）了，同时是最大的正指数（255减去127）但是由于一些特殊情况，比如正负无穷和NaN的存在，导致实际上最大正指数是254-127=127，同理最小其实是1-127=-126\n\n\n\n\n\n\n提示\nIEEE754浮点标准即此方法\n\n此时表示范围也很明确了，比如正数范围最大是：，即除了第一位符号位是0，其他位全为1的数字。正数范围最小则为后23位是1，指数为全0的数：\n负数区间和正数区间完全对称，此处略。\n双精度浮点IEEE754还规定了双精度浮点，也就是占据64位的浮点数，与单精度浮点区别如下：\n范围绝对值为从到\n特殊情况编码规则如下表：\n上溢和下溢当一个数绝对值超过了上界就是上溢，当作正负无穷处理，如果绝对值在下界和0之间那就是下溢，当作0来处理\n补码的几种常见运算计算相反数的补码很简单，先算正数的，之后全部取反再加一。比如我们计算-14的补码：\n\n14是\n取反就是\n再加一得到-14的补码：同理，从-14得到14的补码也是取反再加一，这种方法适用于所有求相反数的情况。\n\n减法补码的优势在减法中充分体现：我们知道计算x+y很简单，只需要按位加法就行，只需要一套关于加法的电路，而补码的优势在于求减法的时候x-y可以变成**x+(-y)**，这时候就把减法化成加法和相反数了（在相反数的过程中也只有一次加法）。\n位拓展符号拓展需要先把一位的符号位复制过去到高位，其余对应位数对应复制过去即可。如下：\n符号拓展其实本质是一样的，但是高位全部置0，低位复制过去即可：\n比较=、≠、&gt;、&lt;、≥、≤这六种比较都可以通过&lt;和=符号来实现，此处略，很简单的。\n小于符号的实现我们判断a小于b是通过a-b小于0来实现的，实际使用中判断a-b的符号位即可判断是否小于。\n符号数在一个字是4bit的时候，遇上，的时候，结果会因为溢出，变成，此时符号位变成了1，判断为a比b小，很明显是不对的。对于这种情况我们就需要符号位拓展：\n\n2个N位二进制补码的操作数均扩展1位符号位（即在最高位的左侧加上一位一摸一样的符号位）\n进行N+1位二进制补码的减法计算\n\n此时会发现，符号位为0，那么判断为a比b大，符合实际情况。\n无符号数如果两个数都是无符号数，需要将这俩个数视作符号数之后符号位拓展，并且都拓展一个0即可同上判断了。\n相等符号的实现\n使用XOR运算得到一个c，对c的每一位做OR运算得到一个bit，为1则为假，反之为真\n执行减法运算得到一个c，之后同上\n\n乘法基本原理就是无符号数的乘法。步骤就是先把a和b的绝对值按照无符号数乘法算出来，最后单独判断符号。TODO:讲义内没说怎么做的无符号数乘法，后面再看无符号数乘法和手算乘法一样，但是由于只有0和1更加简单，对应每一位乘数，如果该位为1，则将被乘数复制到位积内，若为0，这该位对应的位积为0，从低位到高位每个乘数的位都进行一次操作，最后按照乘数每一位的位置n，对各个位积向左移位n次，再累加即可。\n除法对于计算机来说除法最难实现，核心是“试商”。对于二进制数，商只会有0和1两种情况，较为简单：\n\n计算商的每位时，仅需做一次减法\n根据减法结果的符号位判断是否够减如下图所示：\n\n无符号数除法流程与上方相同，每次从被除数取出一位，构成中间余数的末位，然后“试商”，用中间余数减去除数，根据结果判断商的这一位是否为1，如果除数有N位，一定记住符号位拓展，中间余数得拓展到N+1位。\n符号数除法先取绝对值做除法，之后单独判断符号，略。\n总结计算机基本认识没啥用，随便看看得了\n数制\n掌握变换数制的方法\n掌握浮点数的编码（1+8+23）\n了解加减乘除运算的原理（都是基于加法（和一些内置运算））\n\n","slug":"buaa-co-pre-1","date":"2024-07-26T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理,编码","author_index":"大仓鼠"},{"id":"73415a1b5e681c28d78c3a872e437bc5","title":"折腾笔记-基于GithubPages制作博客里世界","content":"折腾目标当前有什么\n\n\n\n\n\n已经备好了\n一个已经实名的顶级域名\n\n我要干什么\n\n\n\n\n\n目标\n搭建一个Github Page并且和本地HEXO利用git联动建立二级域名CNAME解析到新的博客二级域名SSL安装好网站访问加速（TODO）\n\n折腾开始！建立Github Pages进入Github，点击你的repo进去并且点击new从而新建一个repo。输入你的repository名字，必须为你的用户名.GitHub.io这个格式。其他的选项都可以默认即可进入新建的repo，点击settings，在source选择deploy from a branch至此，GitHub这边初步配置差不多了，目前你访问你的用户名.github.io暂时还不会有反应，因为GitHub pages更新页面需要时间，而且默认会扫描index.html&#x2F;README.md&#x2F;index之类的文件作为首页，但是目前repo是空的，所以不会显示任何内容，但是这是正常的，我们之后会往GitHub上面部署我们的网站。\n\n一点修改（感谢2006-TrickEye）\n其实不一定非要是username.github.io，如果你对你的名字叫做repo的仓库打开GitHub Pages，部署出来的结果会挂到username.github.io&#x2F;repo&#x2F;下面\n\n本地配置hexo首先你需要安装Node.js 和 npm，此处可以参考✨这个网页✨，务必记住配置环境变量，但是你使用这个网页内的Windows Node版本管理器内的nodist的话就不需要自己设置了，安装好直接下一步就好。\n以上安装好之后效果如下，如果没有的话检查一下环境变量的path里面有没有对应的文件夹：\nbash$ npm --version\n10.8.2\n$ node -v\nv20.9.0本地新建文件夹，比如叫做blog，用来存放本地hexo仓库文件，在powershell里面打开这个文件夹。之后的步骤因为不可抗力原因🧱，请使用科学上网，如使用代理的话请输入下面的命令：\nbash$ npm config set proxy http://127.0.0.1:你自己的代理端口\n$ npm config set https-proxy http://127.0.0.1:你自己的代理端口如果你实在没有代理，那么可以换淘宝源：\nbash$ npm config set registry http://registry.npm.taobao.org/\n$ npm config set registry https://registry.npmjs.org/\n\n\n\n\n\n如果你不知道的话有一个小tips\n大部分clash默认http和https的混合端口为7897但是你明明可以点开看一眼的……\n\n之后就可以快乐安装hexo辣！依次输入以下命令即可：\nbash$ npm install -g hexo-cli\n$ hexo init\n$ hexo s\n\n\n\n\n\n\n注意\nhexo init由于需要连接github，但是众所周知会出现网络问题，如果你能连上的话这里就忽略掉吧，连不上的可以按照下面的方法解决。你需要把C:\\Users\\你的电脑用户名\\AppData\\Roaming\\npm\\node_modules\\hexo-cli\\lib\\console\\init.js里面的内容如下修改：\njavascript本来是这样的：\nconst GIT_REPO_URL = &#39;https://github.com/hexojs/hexo-starter.git&#39;;\n你得改成这样：\nconst GIT_REPO_URL = &#39;https://github.com.cnpmjs.org/hexojs/hexo-starter.git&#39;;\n\n在hexo init之后你会发现你的文件夹里面变成了这样：如果略有不同不用担心，我这个已经是部署之后的了，改了好些。之后进浏览器输入localhost:4000，就可以看见默认的hexo静态网页了！\n本地配置git并和GitHub连上之后你需要安装本地的git，如果你是Linux，那么只需要用你系统的包管理器安装即可，此处忽略，如果你是Windows，请去✨官方网页✨下载安装，安装过程全部默认就行，并且同样的，你需要把git给放到环境变量里面。\n但是众所周知，我们网络是十分安全滴，所以你需要设置好ssh来连接。进入git的命令行（git bash），输入：\nbash$ cd ~/.ssh\n$ ssh-keygen -t rsa -C &#39;你GitHub注册用的邮箱地址&#39;这个时候你C盘用户文件夹里面.ssh文件夹中就多了id_rsa和id_rsa.pub这两个文件了，双击用记事本（或者vscode之类的编辑器）打开id_rsa.pub复制里面的key。\n之后进入GitHub网页，右上角头像点开，选择settings：点击SSH and GPG keys，选择New SSH key：之后把你剪贴板复制到key里面就行，名字填任何什么都行。\n最后我们验证+绑定一下：\nbash$ ssh -T git@github.com\n$ git config --global user.name &quot;注册时用户名&quot;\n$ git config --global user.email &quot;注册时邮箱&quot;远程部署hexo回到你的hexo本地目录，编辑一个叫做_config.yml的文件，拉到最下面deploy一项，如下修改：\nymldeploy:\n  type: git\n  repository: https://github.com/你的用户名/你的用户名.GitHub.io.git\n  branch: main修改后即可部署，一般来说你还需要安装一个工具：\nbash$ npm install hexo-deployer-git之后就可以三件套（清理、生成、部署）：\nbash$ hexo clean\n$ hexo g\n$ hexo d耐心等待几分钟之后，你就可以在你的用户名.github.io看见你的网站辣！\n设置dns解析在你的域名提供商那里找到dns解析一项，博主此处以阿里云的万网为例：我们需要添加一条CNAME记录，从而将一个域名解析到另一个域名。\n之后在你的本地hexo文件夹里面的source里面新建一个文件，名字叫做CNAME，无后缀，内容填写为你的域名，比如我的域名是buaa.spotterblog.cn，只需要写进去保存即可，我在此处用的是二级域名，如果你是顶级域名的话也一样写进去即可。\n之后再次三件套就好啦！\nbash$ hexo clean\n$ hexo g\n$ hexo d为了更完美一些，回到你的repo的设置，点到pages里面，我们会发现Custom domain已经变成了我们CNAME这个文件中写的内容了，我们勾选上下方的Enforce HTTPS即可，GitHub会为我们的域名自动申请并安装SSL证书，我们就可以用HTTPS安全的访问我们的博客了！\n折腾总结我们弄好了本地HEXO与git，并且部署到GitHub，利用GitHub Pages托管了我们的网页，同时把自己的域名解析到了GitHub的给我们的域名上，实现了用自己的域名访问。\n一些附加内容由于GitHub Pages访问慢，我们可以把图片挂到各类OSS上，博客文章直接引用外链即可，并且利用CDN来实现加速访问，同时Cloudflare也能实现内地的加速。\n","slug":"net-daily-ssl-domain","date":"2024-07-25T16:00:00.000Z","categories_index":"折腾笔记,网页","tags_index":"GithubPages,SSL,Nginx","author_index":"大仓鼠"}]