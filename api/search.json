[{"id":"a9e7097f73f9d5d3ab8d9233687f3fe7","title":"北航计组-预习7-机器语言3","content":"机器语言3存储型程序概念挺概念的，预习的时候看一下差不多得了，期末复习指不定会考（?）\n程序存储概念\n指令以二进制方式被编码\n程序存储在存储器中；可以从存储器中读取程序也可以写入程序，程序和数据以相同方式存储\n简化了计算机系统的软件/硬件设计\n存储器技术既可以存储数据，也可以存储程序\n由于存储在存储器单元中，因此指令和数据都有地址\n\n简单来说，程序就是一串01数据，和其他数据别无二致。\n二进制兼容正如我们上面所说，程序以二进制的形式发布，并且程序与指令集直接有很强的相关性。\n对于新机器来说，较新的指令集有更多的新指令，因此可以运行基于新指令集的新程序，但是新机器也最好适配老程序，即向后兼容。\n指令是什么MIPS里面所有指令的二进制宽度都是一个字，即32位。\n这32位会被划定成若干个域，即代表特定含义的若干位，同一指令的不同域的含义不同，但是对于不同指令来说，不同指令的同一个域的意思大致相同。和数据区分开的是，数据的32位一般视作一个整体，不是多个域。\nMIPS的三类指令\nI型指令：包含立即数的指令\n除了addi、addiu这类比较明显的，lw sw由于包含偏移的立即数，也属于I型，更隐蔽的还有beq bne这俩B类指令，由于其第三个参数其实也属于一个16位的数，并且是直接用的，因此也是I类指令。\n\n\nJ型指令：j和jal。\nR型指令：除了以上这两类之外其他的指令，即寄存器型指令。（srl和jr都是R型指令）\n\n分类可能看起来有些奇怪，我们下文会解释的，其实挺正常。\nR-指令格式这类指令包含六个域，分别的长度和名字如下：\n\n\n\n\n\n\n\n\n\n每个域都被视为无符号整数。\n指令分析\nopcode(6):代表指令操作，R型指令的opcode固定为0b000000。\nfunct(6):与opcode组合，精确定义指令的具体操作，不同指令的funct不同。（主要服务于R型指令，因为R真的多）\n因此可见，MIPS最多有64条R型指令。\n\n\nrs(5):指定第一个操作数，亦即source寄存器。\nrt(5):指定第二个操作数，亦即target寄存器。\nrd(5):指定结果回写的寄存器，亦即destination寄存器。\n比如add  rd,rs,rt\n有的域可能不生效，和具体指令有关。\nMIPS只有32个寄存器，因此5位二进制足够。\n\n\nshamt(5):移位指令中的移位位数（杀……杀马特？）。\n一个寄存器只有32位，因此移位也只需要5位二进制。\n除了移位指令，该域固定为0b00000\n\n\n\n指令示例指令：add $8,$9,$10含义：把$9和$10寄存器里面的有符号数加起来（检测溢出），存储到$8里面。\n域（10进制）:\n\n\n\n高位\n0\n9\n10\n8\n32\n低位\n\n\n\n域（2进制）：\n\n\n\n高位\n000000\n01001\n01010\n01000\n100000\n低位\n\n\n\n\n\n\n\n\n\n\n\n\n如上的二进制编码其实就是机器码\n\n两种略微神金的表达方式\n16进制：0x012A402010进制：19546144一般不会写10进制的……\n\n特殊指令-NOPNOP即对应16进制为0x00000000的指令，按照R型指令翻译：\n\nopcode：0b000000，R型指令\nrs：0b00000，$0\nrt：0b00000，$0\nrd：此处无意义\nshamt：0b00000，移位为0\nfunct：0b000000，代表sll指令，逻辑左移\n\n因此指令为：sll $0,$0,0，功能是解决流水线冲突，是一条特殊指令。\nI-指令格式I型指令只包含四个域，分别大小和命名如下：\n可见前三个域和R型指令相同，最重要的是opcode也在相同位置。\n指令分析\nopcode(6):代表指令操作，此处为一个非0编码。\nrs(5):指定第一个操作数，亦即source寄存器。\nrt(5):指定第二个操作数，亦即target寄存器。\ntarget并非一直都是“目标”，比如lw里面rt就是代表的“读取”\n\n\nimmediate(16):无符号或者有符号数\n无符号：位运算指令（and、or等），小于置位指令（slti等）\n有符号：分支指令（beq、bne等），访存指令（lw、rw等）\n\n\n\n指令示例指令：addi $21,$22,-50含义：把$22寄存器里面的有符号数和加起来（检测溢出），存储到$21里面。\n域（10进制）:\n\n\n\n高位\n8\n22\n21\n-50\n低位\n\n\n\n域（2进制）：\n\n\n\n高位\n001000\n10110\n10101\n1111111111001110\n低位\n\n\n\n32位立即数有宝贝可能会问，哎呀那addi，ori等这些立即数指令不都是可以塞32位立即数吗，那怎么你之前只有16位的空间呢。\n\n\n\n\n\n\n\n\n\n不难看出addi，ori，slti等等涉及32位立即数的指令基本都是伪指令。\n解决方法-lui我们增加了一条新的指令：lui，即Load Upper Immediate。\n\n用法：lui reg,imm\n即把16位的imm写到reg的高16位，reg的低16位全置0。\n\n比如，我们需要执行addi $t0,$t0,0xABABCDCD这一条伪指令，汇编时会被转换为三条：\nasmlui $at, 0xABAB     # 高16位\nori $at, 0xCDCD     # 低16位\nadd $t0, $t0, $at   # 赋值给$t0\n\n\n\n\n\n\n注意\n$at不应该由程序员自己使用，只应该交给汇编器使用，手工编写的时候应该避开$at。\n\nB类指令即分支指令，比如beq src1,src2,label，其中第三个操作数对应的就是指令里面的立即数。（当然rt域也并非一定是寄存器）\n分支指令一般用于构造while、if-else之类的结构，跳转范围一般是几十条指令，不会太远，如果是函数调用之类的建议使用J型指令。\n\n\n\n\n\n\nPC相对寻址\n对于B类指令，基本都是PC相对寻址，具体计算方法是：\n\n若结果为假：\n若结果为真：\n\n可能有人疑问为什么要乘四，这涉及我上次预习提到过的，存储器按照字节编址，但是指令都是按字对齐，因此对于指令来说，后两位一定为0，因为每两条指令之间存储器地址差值为4，也就是0b100，所以B类指令的立即数并不需要浪费两位，于是为了扩大一点有效范围，因此只记录除了最低两位后的16位。\n至于为什么基地址是，这个我们后续慢慢看。\n\n\n\n\n\n\n\n\n\n\n我们对B类指令的跳转范围估算一下，16位的二进制数是，由于立即数要乘以四，所以转移的指令数也是，按照单向估算，一行C语言大约对应10条指令，因此可以转移的代码块大小大约行。让我想起来一个经典笑话：判断一个10000以内的数是奇数还是偶数，一老哥写了10000个switch-case，结果没法编译，手机拍屏发贴吧问。这里没法编译我估计就是因为超出了跳转范围（也许）。\n一个B类指令的示例asmLoop:\nbeq     $9, $0, End\naddu    $8, $8, $10\naddiu   $9, $9, -1\nj       Loop\nEnd:我们得认识到，label的本质就是一个16位立即数，这个label会在汇编编译的时候被“替换”成一个立即数，其值是从该指令到对应label的距离，这一步编译器会帮我们完成，所以如果你真的在这里用了非标号的立即数的话，一定要注意，这个时候就不是编译器帮你做这个了，你得自己数清楚，修改代码的时候这个立即数有可能需要修改，不然bug就来了。如上代码中，End标号对应立即数就是3，因为需要跳过beq到下面End:标号之间的三条指令。\n\n\n\n\n\n\n\n\n\nbeq的opcode是4（查手册），因此构造上面那个B类指令可以构造出：四个域分别为4、9、0、3，那么表示为二进制为：0b 000100 01001 00000 0000000000000011\n大范围跳转当你需要跳转很大区域的时候，可以组合使用B类指令和J类指令，利用J类指令跳转范围更大的特点实现跳转：\nasmbne $s0, $0, Next   # s0里面等于0的时候判断为假，执行下一条j指令\nj   far             # 跳转很远的地方\nNext:\n# 下一条指令\n# ...\nFar:\n# 需要跳转到的指令J-指令格式J指令只有两个域，其范围和名字如下：可以看出，opcode依旧在同一个地方，并且地址范围高达26位（左移两位是28位），已经很大了。\n\n还想跳得更远？\njr指令按照寄存器里面的值跳转，理论上可以跳转32位（左移是34位）的地址，也就是4GB（bytes）。但是jr是R型指令\n\n（伪）绝对地址寻址基本就是J型指令的寻址方式：\n\nPC的高四位来自当前指令的高四位\nPC的低28位用来寻址，也就是J型指令的instr_index的26位左移两位得到的。\n\n这么来看的话，目的地址和当前指令必须位于同一个区段，也就是说，地址转写成16进制后第一位数必须一样，因此j的转移范围就是256MB，确实很大，但是不是最大。\n\n\n\n\n\n\n区段的一种理解\n个人理解，区段就是主存中地址十六进制第一位相同的一片区域。\n\n\n小结\n现代计算机都是程序存储型的\n指令和数据都存在主存里面\n读取指令与读取数据完全可以使用相同的硬件机制、\n指令与数据位于不同区域\n通过PC读取的“32位01串”都被CPU当做指令\n通过Load/Store指令读写的“32位01串”都被CPU当做数据\n\n\n\n\n三型指令：I/J/R\nB类指令使用PC相对寻址，J指令使用（伪）绝对地址寻址\n\n\n附：手动汇编机器码步骤\n\n标识出指令类型（R/I/J）\n标识出正确的域\n用10进制表示各个域的值\n把各个域的10进制转换为2进制\n用16进制表示整个机器码\n\n\n\n\n附：手动反汇编机器码步骤\n\n用2进制表示指令\n根据opcode标识出指令类型（R/I/J）\n用10进制表示各个域的值\n用标识符表示各域，并添加相应的标号\n用汇编格式书写代码\n将汇编代码翻译为C\n\n\n\n","slug":"buaa-co-pre-7","date":"2024-08-08T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理","author_index":"大仓鼠"},{"id":"3a8b96be6df1404e93229a67455be352","title":"北航计组-预习6-机器语言2","content":"\n\n\n\n\n\n\n\n\nMIPS按照字节编址……给哥们记住了，不是bit，是byte！\n机器语言2不等式数学上我们有四个不等关系：   \n但是在MIPS里面，我们只需要一条指令（配合beq bne $0）就可以实现这四种关系。\n小于指令Set on Less Than，即slt，用法和其他指令也差不多，即slt dst,src1,src2，当的时候，就会往dst写入1，否则写入0。\n其他符号的实现以下a均存在$s1里面，b均存在$s2里面：\n实现小于cif(a &lt; b){\n    /* then */\n}asmslt   $t0, $s1, $s2\nbne   $t0, $0, then实现大于等于cif(a &gt;= b){\n    /* then */\n}asmslt   $t0, $s1, $s2\nbeq   $t0, $0, then实现大于cif(a &gt; b){\n    /* then */\n}asmslt   $t0, $s2, $s1\nbne   $t0, $0, then实现小于等于cif(a &lt;= b){\n    /* then */\n}asmslt   $t0, $s2, $s1\nbeq   $t0, $0, then\n\n\n\n\n\n提示\n总结一下，先把带等于符号的取个反，小调等于号之后看哪一边需要小，需要小的一侧在slt指令里面放在src1的位置，之后根据之前是否取过反，第二个指令默认bne，取反就是beq。不过这都看个人喜好，怎么用还是随你。\n\nslt的变形\nsltu，即无符号数比较。sltu dst,src1,src2\nslti，即和立即数比较。slti dst,src,imm\nsltiu，即和立即数进行无符号比较。sltiu dst,src,imm\n\n\n一些题外话\n在MIPS里面signed和unsigned的意思很多样，但是万变不离其宗：\n\n符号位拓展：\nlb要拓展，lbu不拓展。\n\n\n溢出：\nadd sub addi mult div都要检测，而这几个指令后面加上u（即addu等）就不检测。\n\n\n符号数：\nslt slti符号数比较，sltu sltiu是无符号数比较。\n\n\n\n\n\n伪指令MIPS里面定义了一组伪指令，使得程序更加容易编写：\n\n伪指令并不是真正的指令\n伪指令只是为了增加可读性\n伪指令终究会被转换为真正的指令\n\n常用的伪指令\nMove\nmove dst, src，把src赋值给dst。\n\n\nLoad Address\nla dst, label，加载label对应的地址给dst。\n\n\nLoad Immediate\nli dst, imm，加载一个32位立即数给dst。\n\n\n\n\n\n\n\n\n\n如果你没懂为什么label是地址\n在汇编里面，我姑且把每一行对应的指令理解成这行所在的端被移动至某个cpu寻址寻的到的地方开始运行，而标号标定的就是这一行（或者最近的下一行）对应的地址，这个地址是由端的基地址加上偏移得到的，从而j或者beq bne之类的指令可以实现跳转。\n\n汇编寄存器由于伪指令的存在，许多伪指令的实现都需要多条真实指令，并且可能需要至多一个中间寄存器来传递数据，MIPS保留了$at，也就是$1作为汇编器专用的寄存器，其他程序不应该再去专门使用这个$at寄存器。\nTAL和MAL\nTAL：True Assembly Language\n真实的指令，计算机可以理解与执行。\n\n\nMAL：MIPS Assembly Language\n除了TAL的部分，还包含伪指令，每条MAL对应一条或者多条TAL指令。\n\n\n\n由此可见，\n实现函数一般步骤\n调用者把参数放置在某个地方以便函数能访问（$a0~`$a3`）\n调用者转移控制给被调用的函数（jal）\n函数获取局部变量对应的空间\n函数执行具体功能\n函数把返回值放置在某个地方，然后恢复使用的资源（$v0~`$v1`）\n返回控制给调用者\n\n函数相关寄存器我们尽量用寄存器，毕竟主存比较慢，因此需要几个寄存器专门用于传递参数。\n\n传递参数进入的寄存器：$s4-$s7这四个，分别被命名为$a0-$a3\n返回值的寄存器：$s2和$s3，名字叫做$v0和$v1\n返回地址寄存器：用来保存调用者的地址，是$s31，叫做$ra\n\n函数调用指令\nJump and Link：jal\n用法：jal label\n把jal的下一条指令保存在$ra，之后跳转到label\n一般用于调用函数\n\n\nJump Register：jr\n用法：jr src\n无条件跳转到src寄存器保存的地址，一般我们就用$ra\n一般用于从函数返回\n\n\n\nPC寄存器Program Counter是一个特殊寄存器，保存的是当前正在进行的指令的地址。\n\n\n\n\n\n\n提示\n\nPC寄存器是冯氏体系结构计算机的关键环节。\nMIPS里面PC对于程序员不可访问，但是jal指令可以访问。\njal保存到$ra寄存器的是，而不是本身，不然jr跳回来的时候又到了jal了，形成死循环。\n\n\n\n函数调用示例c...\nc = sum(a, b);\n...\n\nint sum(int x, int y){\n    return x + y;\n}asm# a-&gt;$s0 b-&gt;$s1 c-&gt;$s2\n...\n1000  addi  $a0, $s0, 0   # x = a\n1004  addi  $a1, $s1, 0   # y = b\n1008  jal   sum\n1012  addi  $a2, $v0, 0   # c = sum(a,b)\n...\n\n...\n2000  sum: add  $v0, $a0, $a1   # $v0 = x + y\n2004  jr  $ra                   # return $v0\n...保存和恢复寄存器原因由于寄存器很少，只用这点寄存器来编写程序属实是巧妇难为无米之炊，并且由于你只有一个$ra，如果出现了函数的嵌套调用，这个寄存器会被新的调用覆盖，导致无法跳转回最初的调用者，因此我们必须像个办法来保存寄存器到某个地方。\n\n\n\n\n\n\n提示\n寄存器保存在栈里面！\n\n因此我们保留了一个寄存器，对应$29，名字叫做$sp，即栈指针寄存器，指向栈的底端。（stack pointer）\n主存分配的基本方案stack frame即栈帧，实际上就是把$sp朝地址0方向移动之后得到的空间，并且由于栈帧容量是按照byte字节（=8bit）来算的，因此其容量就等于需要保存到寄存器数量乘以四（每个寄存器4个bytes）。当你移动了栈底指针后，就可以用这个寄存器加上偏移量的方式来表示你所需的保存过的寄存器了。\n\n\n\n\n\n\n提示\n你可能注意到，这里的表示方法类似于从主存里面取数据的方法，实际上栈就是保存在主存里面的，当然表示方法也一样。\n以及，虽然看起来空间无穷大，但是实际上还是有限的，这也是为什么你在c语言里面递归调用次数太多的时候会爆栈。\n\n当然，由于偏移量都是你自己设置的，入栈之后一定记得及时出栈，并且恢复栈底指针位置，不然后面偏移量都算不清楚。\n多重调用函数示例cint sumSquare(int x, int y){\n    return mult(x, x) + y;\n}asmsumSquare:\n    addi    $sp, $sp, -8    # 移动栈底往下8个字节\n    sw      $ra, 4($sp)     # 保存返回地址寄存器\n    sw      $a1, 0($sp)     # 保存y变量\n    move    $a1, $a0        # 传入mult的第二个参数设置为x\n    jal     mult            # 调用mult，此时$ra保存了下一行指令\n    lw      $a1, 0($sp)     # 取回y变量\n    add     $v0, $v0, $a1   # 计算mult(x,x)+y并保存到返回值里面\n    lw      $ra, 4($sp)     # 取回返回地址寄存器\n    addi    $sp, $sp, 8     # 栈底上移恢复原位\n    jr      $ra             # 返回原调用者\nmult:\n    mult    $a0, $a1        # 乘法运算，ao和a1都是x\n    mflo    $v0             # 低32位传回去，高32位先不管了……\n    jr      $ra             # 返回调用者sumSquare函数的架构我们上面已经了解了如何嵌套调用，因此我们可以看到一个函数如何构成的：\nasm############ 施法前摇 ############\nfunc_label:\n    addi    $sp, $sp, -framesize    # 下移栈底\n    sw      $ra, [framesize-4]($sp) # $ra保存到新区域的顶部\n    # 保存其他传入的参数之类的（比如$s0-$s7）\n\n############ 施法进行 ############\n    # jal调用其他函数\n    # 或者函数具体内容\n\n############ 施法后摇 ############\n    # 取回其他保存的参数\n    lw      $ra, [framesize-4]($sp) # 取回$ra\n    addi    $sp, $sp, framesize     # 恢复栈底\n    jr      $ra                     # 调用结束\n\n\n\n\n\n超过两重嵌套？\n有人可能会有疑问，欸你这万一不止两重嵌套呢，那栈底怎么移动啊，不是只有一个栈底吗？\n其实确实只有这一个（暂时），但是你也可以发现，我们每次调用函数需要移动栈底的时候，最后都移动回原位了的，因此对于每一层的函数，其栈底永远是同一个位置，它不会知道它调用的函数怎么动的栈底，因为对于它本身来说栈底在jal前后就没动过。\n\n局部变量和数组由于寄存器只有32个，因此编译器绝大多数情况下不可能把函数需要的所有局部变量都分配在寄存器，因此我们还是需要移动栈底来保存局部变量。\n图中比我们之前的代码似乎多保存了程序变量寄存器$s0到$s7，临时寄存器以及一些传入传出参数寄存器，其实只要用过的保存一遍就好了，和保存$ra没啥区别，因为$ra是每次jal调用的时候必须用到寄存器，所以至少得保存一个$ra。\n函数调用约定寄存器的保护其实我们上文已经提到过寄存器保护的问题了，保存-调用-恢复的这个过程其实就是寄存器的保护动作，只是对于不同寄存器的保护需求和细节不一样：可见分为强保护和弱保护，也比较显而易见的是强保护对于一整个函数来说都保护了，而弱保护是对于其调用的子函数来说保护了一下，不过我更喜欢叫做前者是被调用者保护，而后者叫做调用者保护，可能比较直观一些。\n保护机制的代码如下：强保护（被调用者）\nasmfunc_label:\n    addiu   $sp, $sp, -framesize    # 分配栈帧\n    sw      $ra, [framesize-4]($sp) # 保存$ra\n    sw      $s0, [framesize-8]($sp) # 保存s0-s7，下略\n    # ...\n    sw      $s7, 0($sp)\n\n    # 使用$s0~$s7\n    # 调用其他子函数\n\n    lw      $s7, 0($sp)             # 取回$s7~$s0，下略\n    # ...\n    lw      $s0, [framesize-8]($sp)\n    lw      $ra, [framesize-4]($sp) # 取回$ra\n    addiu   $sp, $sp, framesize     # 回收栈帧\n    jr      $ra                     # 返回弱保护（调用者）：\nasmfunc_label:\n\n    # 当前函数其他代码\n\n    addiu   $sp, $sp, -framesize    # 分配栈帧\n    sw      $t0, [framesize-8]($sp) # 保存t0-t7，下略\n    # ...\n    sw      $t7, 0($sp)\n\n    jal     child_func              # \n\n    lw      $t7, 0($sp)             # 取回$t7~$t0，下略\n    # ...\n    lw      $t0, [framesize-8]($sp)\n    lw      $ra, [framesize-4]($sp) # 取回$ra\n    addiu   $sp, $sp, framesize     # 回收栈帧\n\n    # 当前函数其他代码\n\n    jr      $ra                     # 返回\n\n\n\n\n\n提示\n$t0等临时寄存器可以不保护，只需要保证子函数不改变这个寄存器就行。\n但是$s0等程序员变量寄存器，如果一个函数使用了这些，就必须在进入和退出函数的时候分别保存恢复。\n\n小结\nbeq和slt可以实现各种比较（还有bne）\n伪指令增加易读性，但是可能不止对应一条真实指令，可能多条\n函数调用与返回（以及栈）\n\n","slug":"buaa-co-pre-6","date":"2024-08-06T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理","author_index":"大仓鼠"},{"id":"8a3d05455b8690208682c71c22ab04dc","title":"北航计组-预习5-机器语言1","content":"机器语言1机器语言概述从代码到运行主要分为五个步骤：编译-汇编-存储-加载-运行。也就是从程序编译成汇编程序，再从汇编变成机器码，之后存到硬盘内，加载到主存储器中，最后交给CPU运行。\n编译编译器把高级语言（比如C语言）转化为汇编代码的过程。\n\n高级语言：适合人类书写和阅读\n汇编代码：稍微接近CPU理解和执行的语言（但是并非直接理解）\n\n通过编译可以把像这样的c语言代码：\ncwhile(1)\n    if(*p){\n        *q = *p;\n        p++;\n        q++;\n    }\n    else\n        break;翻译成这样的汇编代码：\nasmLoop_Start:\n    lbu     $t1, 0($s1)\n    sb      $t1, 0($s2)\n    addiu   $s1, $s1, 1\n    addiu   $s2, $s2, 1\n    beq     $t1, $0, Loop_End\n    j       Loop_Start\nLoop_End:汇编为了让CPU运行程序，还需要一次将汇编代码转换成机器码（也就是0101的串）的转换。区别如下：\n\n汇编程序：每行都是一条机器指令\n机器指令：由一组二进制01串组成，是CPU可以理解与执行的。\n\n存储C程序被编译为一组CPU指令后，就以文件方式被存储在硬盘中，其实就是二进制存储的。\n加载从硬盘读盘到内存里面，也就是主存储器，加载过程中指令和数据分开载入，分别在内存中的不同位置：\n\n代码段：存储CPU指令\n数据段：存储数据\n\n运行CPU运行程序无非就是如下的一个循环：\n\n读取指令：从内存代码段读取一条指令\n分析指令：分析指令功能\n执行指令：控制内部功能并执行操作\n\n\n\n\n\n\n\n\n\n\n对于RISC来说，只有读写主存的指令能够传输数据，下文会提到\n指令集如果说指令是CPU懂的单词，那么指令集ISA就是CPU理解的全部单词的集合\n\n如果只有一种ISA：可以很好的利用公共软件，如编译器、操作系统等\n如果有很多种不同的：不同的指令集有不同的设计平衡性考虑，有更适用的ISA\n\nRISCReduced Instruction Set Computing (RISC)\n\n加速大概率事件\n便于设计，电路频率更高\n简单功能交给硬件，复杂功能交给软件\n\n设计原则\n指导思想：CPU越简单性能越高\n设计目标：减少指令数量，去除复杂指令\n基本策略：\n指令定长：所有指令都占用32位（1个字），降低了从存储器中读取指令的复杂度\n简化指令寻址模式：以基地址+偏移为主，降低了从主存中读取操作数的复杂度\nISA的指令不仅数量少，而且简单，降低了指令执行的复杂度\n只有load与store两类指令能够访存\n把复杂留给编译，即编译器将高层语言复杂语句转换为若干简单的汇编指令\n\n\n\n\n\n\n\n\n\n\n\n\n我们选择学习MIPS是因为MIPS是RISC的典型代表，并且是真正的工业CPU\n寄存器计算机硬件的操作数对于c语言来说，变量的数量上限只被内存大小卡了，而且我们一般不考虑内存限制（除非是打acm……）对于ISA来说，有一组数量有限的而且一般是固定的操作数，叫做寄存器。\n\n\n\n\n\n\n\n\n\n小声bb：我姑且把寄存器理解成某种存数字的变量，后面有问题再回来改\n\n寄存器内置于CPU，因此访问速度很快（&lt;1ns)\n寄存器也因此数量少\n\n计算机中的时间单位\n\n\n时间单位\n\n\n\n\n\n\n\n全称\nmillisecond\nmicrosecond\nnanosecond\npicosecond\n\n\n中文名\n毫秒\n微妙\n纳秒\n皮秒\n\n\n换算\n\n\n\n\n\n\n频率等级\nKHz（千）\nMHz（兆）\nGHz（吉）\nTHz（太）\n\n\nMIPS的寄存器有且仅有32个寄存器，每个的宽度都是32位。\n\n\n\n\n\n\n说明\nPPT原文说寄存器没有类型（即无正负）实际上不太对，因为寄存器中只是一个32位的串，具体怎么解释仅取决于指令，而非“无正负”\n\n寄存器数量是均衡设计深思熟虑后的考虑：\n\n数量少：结构简单，速度快，能够存储在CPU内的数据少\n数量多：结构复杂，速度慢，能够存储在CPU内的数据多\n\n\n\n\n\n\n\n\n\n\n思考题：64位太占空间，16位精度或者范围不够用\n寄存器编号：0-31寄存器的表示：$x 其中x为0到31的数字，即从$0到$31寄存器是有名字的：\n\n程序员变量寄存器一般用$s0到$s7命名，对应寄存器编号为$16到$23\n临时变量寄存器是$t0到$t7（对应$08到$15），和$t8、$t9（对应$24和$25）\n\n这样可以稍微提高一点汇编代码的可读性……也许吧\n指令和立即数MIPS指令指令格式asmop dst, src1, src2其中：\n\nop：指令的功能\ndst：保存结果的寄存器\nsrc1：第一个操作数\nsrc2：第二个操作数\n\n如此，这种固定的格式既有助于人理解与编写，也可以使得硬件变得简单。\n\n\n\n\n\n\n提示\n硬件越简单，延迟越小，时钟频率越高。\n\n指令的特点\n每条指令有且仅有一个操作\n每行有且仅有一个指令\n和C语言的运算紧密相关（其实这个该算C语言的特点了吧）\n一行C代码会对应多条指令\n\n例子假如有三个变量a b c分别存在三个寄存器$s1 $s2 $s3之中，以下c语言代码可以写成MIPS的汇编形式：\nca = b + c;\na = b - c;asmadd $s1, $s2, $s3   # a = b + c\nsub $s1, $s2, $s3   # a = b - c那如果一行c语言代码有多个运算呢？那就得折磨编译器了为了保证每行只有一条指令，一种对于x = (a + b) - (c + d)的可能实现如下：\nasm# 假设x,a,b,c,d分别对应s0-s4这五个寄存器\nadd $t1, $s1, $s2   # t1 = a + b\nadd $t2, $s3, $s4   # t2 = c + d\nsub $s0, $t1, $t2   # x = t1 - t2我们在这之中使用了两个临时变量寄存器。\n\n欸！我也有一道自制的小题💡🤓👆\n其实编译器能够做到的相比直接翻译代码来说会更多一些，你可以尝试一下不使用临时寄存器来把结果算出来。\n\n0号寄存器由于成都人太多数字0在程序中使用频率很高，为此MIPS专门为其分配了一个只读寄存器$0，或者用$zero表示，这个寄存器读出来一定是0，并且写入的数据被丢弃。\n比如我此时需要给变量c（存在$s3内）赋值为0，并且把b（存在$s2内）的值赋给a（存在$s1内）：\nasmadd $s3, $0, $0   # c = 0\nadd $s1, $s2, $0  # a = b立即数\n\n\n\n\n\n\n\n\n也许叫immediate number?\n指令中的常量数值就是立即数，对于立即数来说，加法的汇编操作不太一样(addi)：\nasm# 语法是：op dst, src, imm 其中imm是立即数\naddi $s1, $s2, 5  # a = b + 5\naddi $s3, $s3, 1  # c++数据传输指令这里的数据传输指的是寄存器与主存储器之间的数据交换。\n主存单元寄存器？主存？❌寄存器仅有32个，有限的寄存器存不完大量变量，比如我写sb代码的时候10e8大数组、高维矩阵等等……\n✔所以我们需要主存来解决问题，大部分变量存在主存中，需要用的时候加载到寄存器中。\n主存的抽象模型主存可以被抽象成一个数组，其中存储数据单位为byte（记住了，这玩意是8bit，俩Hex），而存储数据位置就是地址，类似数组下标。\n\n如图的4GB（这里的B是byte哈，不是bit）主存，有4G个存储单元，也就是个存储单元。因此对应的地址为0x00000000到0xFFFFFFFF，地址位数为32位。\n\n\n\n\n\n\n提醒\n注意区分地址的位数和存储的位数，此处地址位数是32位，但是一个存储单元里面只有1byte，也就是8位。\n\n\nCPU字长\ncpu的字长指的是cpu一条指令可以计算的数据的宽度，比如MIPS字长32位，也就是单条MIPS可以计算的数据就是32位。有人问那long long这种数据类型怎么实现的，别急，多条指令照样可以实现，但是这样也损失了一些性能罢了。\n\n如同上文所述，我们一般把CPU抽象成一个二维数组，其中每一行的长度就是CPU字长。（这里仅是一种模拟而已，不要太当真）那么字地址就是某字第0列的单元对应的字节的地址。\n地址的表示方式两种方法\n绝对地址：\n主存单元的地址直接用具体数值表示\n比如下图中黄色单元地址为P = 0xFFFFFFF9\n\n\n相对地址：\n采用“基地址+偏移”的形式表示\n比如以B1为基地址，那么P的地址就是P = B1 + 1\n\n\n\n基地址+偏移的优点\n一致：与数据结构的访问方式一致，比如数组就是基地址+偏移。\n统一：可以用固定base与不同的offset得到任意地址。\n灵活：不同的base和offset可以对应同一个地址，编程更加灵活。\n\n数据传输指令语法asmop reg, off(base)\nreg：写入或读出的寄存器\nbase：存储基地址的寄存器（实际上base被视作无符号数）\noff：以byte为单位的偏移量，可正可负\n\n因此读写的存储单元的实际地址为base + off\nlw/sw指令\nlw：Load Word\n读取地址为base + off的一个字，然后写入reg\n\n\nsw：Store Word\n读取reg，写入base + off\n\n\n\n比如说我们需要汇编如下的c语言代码\ncint A[100];\nA[10] = A[3] + a;假设指针*A存储的地址在寄存器$s3里面，而a变量对应寄存器$s0。\n\n\n\n\n\n\n\n注意\nA[10]在c语言代表A数组的下标为10的位置的值，但是实际上这是一个语法糖，A[10]其实本质上是*(A+10)，其中(A+10)就是int类型指针变量A的内容（也就是一个地址）往后偏移10个int类型（或者其他类型）的长度后对应的地址，那么*(A+10)就是该地址对应的int（或其它类型）的指针指向的长度为int（或其它类型）的内容（也就是一个存到这里的数），这句话可能有点绕，但是多理解一下指针总是好事情不是吗？\n这个时候你去理解为什么A[]可以存在寄存器中就清楚多了，因为A本质上就是一个字长的无符号数（代表地址）（注意区分一下*A代表的才是这个地址内存的值，亦即A[0]），这个无符号数（地址）就是寄存器$s3的内容；同理变量a也有地址&amp;a，这个地址就是寄存器$s0的内容。\n\n\n\n\n\n\n\n\n\n\n因此我也喜欢把寄存器理解成对地址的操作。\n闲话少说，我们通过lw和sw实现汇编如下：\nasmlw $t0, 12($s3)     # $t0 = A[3]\nadd $t0, $t0, $s0   # $t0 = $t0 + a\nsw $t0, 40($s3)     # A[10] = $t0\n\n\n\n\n\n\n特别注意\n如下写法有误\nasmlw $t0, 12($s3) \nadd $t0, $t0, $s0\nlw 40($s3), $t0其原因是必须严格遵循lw和rw的格式，也就是op reg, off(base)，如果后面能换，那我问你为什么会有lw和sw俩指令呢？\n\n主存单元使用的限制MIPS不支持主存单元参与运算，主存单元只能和寄存器进行数据交换，这样便于设计流水线CPU。\n\n\n\n\n\n\n\n特别注意\n以下均错误：\nasmadd $t0, $s1, 0($s2)\nsub $t0, 0($s2), 12都错在用了主存单元里面的东西。\n\n\n\n\n\n\n\nMIPS支持的运算\n寄存器——寄存器：寄存器与寄存器运算，结果写入寄存器。寄存器——立即数：寄存器与立即数运算，结果写入寄存器。\n\nlb/sb指令我们望文生义一下，其实和lw/sw差不多，这俩指令从word变成了byte而已，区别在于，如果涉及主存的话，偏移量可以不为4的倍数。\n\n\n\n\n\n\n\n\n\n我仔细想了一下，其实lw和sw也可以不为4的倍数，只是会写到后面的内存里面罢了吧，等后面再来纠错吧。\n纠错：为了提高运行效率，lw必须得以四的倍数对齐，这样可以避免跨缓存行访问数据，提高性能。\n用法：\nasmop reg, off(base)其实和lw和sw一样，但是需要注意lb在写入寄存器的时候会进行符号位拓展，直接补满高24位，虽然补了，但是作用仅仅是保留符号位，当你调用sb的时候还是只会写入后八位。\n\n\n\n\n\n\n还有个命令\nlbu这个进行的操作就是直接写8个bit，也就是一个byte到寄存器里面，不补符号位（也就是全部补0）。\n\n指令汇总\n字操作：lw sw\n半字操作：lh lhu sh\n字节操作：lb lbu sb\n\n大小印第安（大端小端）\n大印第安：最高有效字节在字内的最低地址\n小印第安：最高有效字节在字内的最高地址\n\n\n\n\n\n\n\n\n\n\n我们这一般用小印第安，低对低，高对高。\n判断指令MIPS一般用标号机制实现转移：\n\nMIPS不像c一样有if/while之类的语句块\n每条指令都对应一个32位（不一定）的地址（一个字）\n为了可读性，一般用字符串加冒号的形式作为标号，标记其后指令的地址：比如ForBegin:\n汇编通过跳转机制到标号处实现转移（类似c语言的goto）\n\n决策指令三个转移指令\nBranch If Equal：即beq，相等的时候转移：\nbeq reg1, reg2, label\n当reg1的值和reg2的值相等的时候，跳转到label处继续运行。\n\n\nBranch If Not Equal：即bne，不相等的时候转移：\nbne reg1, reg2, label\n当reg1和reg2的值不等的时候跳转。\n\n\nJump：即j，无条件转移：\nj label\n无条件，直接跳转，类似c语言的goto\n\n\n\n\n\n\n\n\n\n提示\nB类分支指令的label可以直接用立即数，因为label本来就是立即数，编译的时候“替换”。\n\nif-else的汇编构造方式c语言代码：\ncif(i == j){\n    a = b; // then\n}else{\n    a = -b; // else\n}汇编（beq）：\nasm# i-&gt;$s0, j-&gt;$s1\n# a-&gt;$s2, b-&gt;$s3\nbeq $s0, $s1, then\nsub $s2, $0, $s3\nj end\nthen:\nadd $s2, $s3, $0\nend:汇编（bne）:\nasmbne $s0, $s1, else\nadd $s2, $s3, $0\nj end\nelse:\nsub $s2, $0, $s3\nend:switch-case的构造方式大多数高级程序设计语言都有switch-case结构，我们在MIPS里面可以如下构造：C语言：\ncswitch(){\n    case 条件1:\n        语句块1;\n    case 条件2:\n        语句块2;\n    ...\n    case 条件N:\n        语句块N;\n    default:\n        语句块default;\n}MIPS汇编：\nasm    b类, 条件1, Case1\n    b类, 条件2, Case2\n    ...\n    b类, 条件N, CaseN\nDefault:\n    语句块default\n    j SwitchEnd\nCase1:\n    语句块1\n    j SwitchEnd\nCase2:\n    语句块2\n    j SwitchEnd\n    ...\nCaseN:\n    语句块N\n    j SwitchEnd\nSwitchEnd:\n指令类别\n\nR类：一般用于寄存器-寄存器操作。\nI类：一般用于立即数访问和load操作。\nS类：用于访存store操作。\nB类：用于条件跳转操作。\nJ类：用于无条件操作。\n\n\n\n\n\n\n\n\n\n\n注意，其实我们课里面只分为R/I/J三型，与这里的类区分一下\n\n\n其他分支指令与0比较的分支指令(即bxxz类指令)\n\nblez：小于等于0转移\nbltz：小于0转移\nbgez：大于等于0转移\nbgtz：大于0转移\n\n以上bxxz类指令格式均为\ntxtop rs, label\n\n\n\n\n\n提示\n由于固定和0比较大小，所以就不需要劳烦$0寄存器了。\n\n循环指令？\n\n\n\n\n\n\n\n\nMIPS只需要根据条件转移就好啦！\n比如我们构建一个复制字符串的while循环，从p数组复制到q数组，一种c语言的神金实现如下：\ncchar *p, *q;\nwhile((*q++ = *p++) != EOF);\n如果你不懂这段神金的话……\n\nc语言中，赋值表达式的返回值是左值。\n指针++作用是移动一个类型的空间，++在后表示这一行执行完后再自增。\n\n\n\n汇编后代码如下：\nasm# p-&gt;$s0, q-&gt;$s1\nLoop:\n    lb $t0, 0($s0)\n    sb $t0, 0($s1)\n    addi $s0, $s0, 1\n    addi $s1, $s1, 1\n    bne $t0, $0, Loop运算指令MIPS为高级程序设计语言的加减乘除等算术运算提供了相应的指令，并且可以分为“寄存器-寄存器（R-R）”和“寄存器-立即数（R-I）”两类。\n加减法指令汇总加法有四条：add addu addi addiu减法只有两条：sub subu\n\n\n\n\n\n\n没有subi/subiu的原因\n加上相反数就是减，所以可以用addi``addiu直接实现，多用多浪费嘛。\n\n溢出MIPS会检测溢出，并且溢出时产生错误，当指令有unsigned关键字的时候忽略溢出。\nasm# $s0=0x80000000（即最小的负数）, $s1=0x1\nadd\t   \t$t0, $s0, $s0\t# 溢出错误\naddu\t$t1, $s0, $s0\t# $t1 = 0\naddi\t$t2, $s0, -1\t# 溢出错误\naddiu\t$t3, $s0, -1\t# $t3 = 0x7FFFFFFF\nsub\t\t$t4, $s0, $s1\t# 溢出错误\nsubu\t$t5, $s0, $s1\t# $t5 = 0x7FFFFFFF乘除法HI/LO寄存器注意，乘除法指令中并不存在dst寄存器，因为结果单独存在HI和LO这俩特殊寄存器里面，并不属于之前的32个通用寄存器。有两条特殊的寄存器读指令：\n\nmove from HI：即从HI读取，写入到dst里面（mfhi dst）\nmove from LO：即从LO读取，写入到dst里面（mflo dst）\n\n乘除法指令\n乘法是mult src1,src2\n结果是，并且低32位保存在LO寄存器，高32位保存在HI寄存器\n\n\n除法是div src1,src2\n结果是，LO保存商，HI保存余数\n\n\n\n位运算按位计算我们依旧假设a-&gt;$s1, b-&gt;$s2, c-&gt;$s3，有如下位运算指令：同样的，也分为是否有立即数的两个版本。\n移位指令位移如果用立即数，那就只有0-31有效，如果用寄存器，那就只有第五位（视作无符号数）有效。\n方便记忆来说，s代表移位类指令，第二位l、r代表左右，第三位l代表逻辑（logical），a代表算数（arithmetic），v代表不用立即数，而是寄存器。\n\n\n\n\n\n\n提示\n左移只需要低位补0，所以不需要算术左移，没有意义，而算术右移是要补符号位的，所以得区分。\n\nasmaddi $t0, $0, -256 # $t0=0xFFFFFF00\nsll\t $s0, $t0, 3   # $s0=0xFFFFF800\nsrl  $s1, $t0, 8   # $s1=0x00FFFFFF\nsra\t $s2, $t0, 8   # $s2=0xFFFFFFFF\n\naddi $t1, $s0, -22 # $t1=0xFFFFF7EA 低五位01010即十进制的10\nsllv $s3, $t0, $t1 # $s3=0xFFFC0000","slug":"buaa-co-pre-5","date":"2024-07-31T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理","author_index":"大仓鼠"},{"id":"0d519e95d32b3bfd8b6aa80ad86d4aac","title":"北航计组-预习3-时序电路","content":"\n\n\n\n\n\n\n\n\n一些写在前面的话：我打算还是少一些照抄ppt的内容，以我自己的理解为准，可能理解略有偏差，但是也算是一种不一样的理解一个知识点的方式，所以也是有可取之处的，有问题我也可以及时修改，后面复习也可以参考，大概就这样吧。\n时序电路双稳态电路构成方式一般是由两个反相器构成，这样的作用就在于在不需要外部维持的情况下，稳态电路可以自行维持其一开始的状态。\n\n\n\n\n\n\n提示\n可能有朋友会疑惑，说好的能量守恒呢，你这不可能没有能量损失吧，那我哪里来的高电平啊？实际上在这种电路中，反相器实际上要接电源的，也就是能够提供能量，所以不需要钻牛角尖说这是一个“独立”的电路了。\n\n示意图和真值表ppt中有a和b两张图，实际上只是电路扭了扭而已，二者完全一致。\n\n\n\n\n\n\n\n\n0\n1\n\n\n1\n0\n\n\n需要注意的是，这个真值表看起来并不像是一个正经的真值表，相比我们之前认识的那些真值表，似乎没有能够“主动”变化的变量，但是话说回来这个真值表其实没有问题，只是因为我们不存在随时间变化的问题，所以我们只是枚举了所有（两种）可能的情况，后续我们可能会遇上和历史状态相关的真值表，下午将会提到。\nRS锁存器构成方式和双稳态差不多，把非门换成了或非门，依旧是采用了交叉反馈的方式，连线如下图。\n可能又有朋友疑惑，说欸你这个和以及另一对难道不是同一个东西吗，咋有俩名字。其实确实是同一个东西，只是为了之后写真值表的时候方便分析才这样取了个名字而已，无需在意。\n真值表和特性此处真值表与上一时刻状态可能有关，我们会分为两个部分，前三条为外部输入能够完全确定的部分，后两条为外部输入需要与上一时刻的值一同决定的部分：\n\n\n\nNo.\nS\nR\n\n\n\n\n\n\n1\n0\n1\n-\n0\n1\n\n\n2\n1\n0\n-\n1\n0\n\n\n3\n1\n1\n-\n0\n0\n\n\n4\n0\n0\n1\n1\n0\n\n\n5\n0\n0\n0\n0\n1\n\n\n简单的来说，在S（set），和R（reset）为1、0或者0、1的时候，S取多少，Q就被设置为多少；而S和R同为0的时候我们可以理解成保持，这时候Q的值维持前一时刻的状态。\n一般来说，我们把S取1，Q取0的时候叫做“置位”；S取0，Q取1的情况叫做“清除”。\n\n\n\n\n\n\n\n注意\nS和R不能同时取1，真值表中第三条可以看出，会导致当前时刻和同时变为0，按理说也不是不行，但是我们分析会发现，S和R毕竟是人为控制的，大部分时候会在保持的状态，也就是二者同为0，这时候输出端两个0反馈到输入端，N1和N2两个或非门输出为1，也就是输出突然反转为1了，而这时输出又一次反馈给输入，两个或非门输出变成0，又一次反转。也就是说，输出端在疯狂振荡，可能会导致损坏甚至更严重的问题。\n\nRS的局限性\n语义上来看，寄存器应该实现数据输入输出，但是RS锁存器实现的是置位和归零。PPT里面这么说的，我觉得有待商榷，因为输出端就可以实现数据输出，而输入端接一个非门就可以实现数据输入了，可能老师认为不能加东西吧\n从时序上看：RS不能实现对时间信号的响应，无法被协调操控。\n\nD锁存器结构和形式内部结构：其实就是我RS套壳辣！桀桀桀桀桀\n你要理解D锁存器也很简单，其实就是CLK信号作用到两个与门上面，CLK为0的时候就把与门堵死了，CLK为1就导通给D信号用；而D信号就像我之前说的那样，分成两股，其中一个加上非门，变成了R/S信号给到了RS锁存器，就是这么简单，而D锁存器的一个好处也在这里，完全避免了R和S同为1的非法情况产生。\n真值表此处直接放上简化后的真值表：\n\n\n\nCLK\nD\n\n\n\n\n0\nX\n\n\n\n1\nD\nD\n\n\n局限性由于CLK为1的时候Q始终随D变化，ppt中提到的是没法完全对齐时钟，我觉得更好的说法是，D锁存器只是利用时钟信号做了一个开关，而并非对齐，真正的对齐还得是边沿对齐的方式。并且还有一点就行真实的信号是有抖动的，D信号的不稳定会导致输出的Q也具有相同的抖动，如果后面接了边缘对齐类型的东西的话就会出大问题。\nD寄存器\n\n\n\n\n\n\n\n\n我更喜欢叫“上升边沿触发的D锁存器”\n结构和形式其实是两个D锁存器的串联，加上了不一样的时钟信号，实现了一种隔离。\n真值表和特性信号特性其真值表其实和D锁存器差不多，但是CLK信号分边沿来写即可：\n\n\n\nCLK\nD\n\n\n\n\n↓\n-\n\n\n\n↑\nD\nD\n\n\n也就是说，CLK信号上升沿才会使得Q变化，并且变化为当前D的值。这就很好的避免了在D刚刚变化的时候产生的抖动等问题，也实现了真正的时钟同步。\n时间特性\n 建立时间，Setup Time，即D在边沿前所需要稳定的时间\n 保持时间，Hold Time，即D在边沿后所需要稳定的时间\n 输出延迟，CLK-to-Q delay，在边沿到Q产生变化的时间差\n\n\nD寄存器的拓展应用多路选择器MUX这个其实不是D寄存器，我们先认识一下MUX，这是后续的一个基础：\n作用：根据控制信号取值，让输出信号的取值为多个输入信号的某个取值。简而言之就是，选！\n\n真值表：\n\n\n\nS\n\n\nY\n\n\n\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n\n\n0\n1\n0\n0\n\n\n0\n1\n1\n1\n\n\n1\n0\n0\n0\n\n\n1\n0\n1\n0\n\n\n1\n1\n0\n1\n\n\n1\n1\n1\n1\n\n\n其表达式也不难写出：\n\n\n\n\n\n\n说明\n这里是一个二选一的MUX，以后还会遇上2的n次方选1的情况，这种情况下输入信号数当然是2的n次方，但是我们可以简单分析一下选择信号的数量，利用二进制无符号数可以发现，只需要n位0、1就可以达到选择的作用，所以只需要n个选择信号就能够实现选1的效果。\n\n带使能的D寄存器这其中就用到了二选一的MUX，上文已经提到过了。简而言之就是当EN信号为1的时候才有用，为0的时候就用当作输入，也就是屏蔽了D的信号。\n带同步清除的D寄存器利用一个与门，当reset信号为1的时候，经过一次非门变成0，使得与门输出强制变为0并且作为D寄存器的输入，也就是强制写入0的作用。当然，reset为0的时候，采用的就是原始的D输入啦。\n总结简单的时序电路入门，学习了RS和D锁存器，利用时钟边沿触发的寄存器也学了，引申了一些其他的D寄存器。\n我缺的JK寄存器谁给我补上啊啊啊啊啊，我的JK\n","slug":"buaa-co-pre-3","date":"2024-07-29T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理","author_index":"大仓鼠"},{"id":"106042df361711128e93d1695c28edbf","title":"折腾笔记-hexo、Mathjax、Latex的奇妙bug","content":"前言从来没想过能有这种奇妙问题……\nbug复现我在写笔记的时候需要用到Latex写一些公式，前端用的Mathjax渲染，但是公式换行始终无法解决。\n按道理来说\\\\是可以起到换行的作用的，结果实际如下：\n代码latex\\begin{align*}\nD &amp;= (\\overline{AB})(A+\\bar{B}C) \\\\\n  &amp;= (\\bar{A}+\\bar{B})(A+\\bar{B}C) \\\\\n  &amp;= A\\bar{A}+\\bar{A}\\bar{B}C+A\\bar{B}+\\bar{B}\\bar{B}C \\\\\n  &amp;= (\\bar{A}+1)\\bar{B}C+A\\bar{B} \\\\\n  &amp;= \\bar{B}C+A\\bar{B} \\\\\n  &amp;= \\bar{B}(A+C)\n\\end{align*}现象\nbug原理和修复Mathjax其实不需要背锅，出问题的是markdown把\\\\转义成\\了，因此前端代码渲染出来的是\\的效果。所以我们需要把latex代码里面的\\\\全部替换成\\\\\\\\，由此就可以转义变成\\\\正确渲染了：\n代码latex\\begin{align*}\nD &amp;= (\\overline{AB})(A+\\bar{B}C) \\\\\\\\\n  &amp;= (\\bar{A}+\\bar{B})(A+\\bar{B}C) \\\\\\\\\n  &amp;= A\\bar{A}+\\bar{A}\\bar{B}C+A\\bar{B}+\\bar{B}\\bar{B}C \\\\\\\\\n  &amp;= (\\bar{A}+1)\\bar{B}C+A\\bar{B} \\\\\\\\\n  &amp;= \\bar{B}C+A\\bar{B} \\\\\\\\\n  &amp;= \\bar{B}(A+C)\n\\end{align*}现象\n","slug":"hexo-mathjax","date":"2024-07-28T16:00:00.000Z","categories_index":"折腾笔记,网页","tags_index":"hexo,Mathjax,Latex","author_index":"大仓鼠"},{"id":"98d48bfcc3d8d2c9c7bc42d4a7352b22","title":"北航计组-预习2-从门电路到运算","content":"门电路电路类型同步数字电路有两种类型：\n\n组合逻辑\n输出只是输入的函数，和历史状态无关\n如：加法器\n\n\n时序逻辑\n能够存储信息，也即是与历史状态有关\n如：寄存器\n\n\n\n逻辑门NOT真值表：\n\n\n\na\nc\n\n\n\n0\n1\n\n\n1\n0\n\n\nAND真值表：\n\n\n\na\nb\nc\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\nOR真值表：\n\n\n\na\nb\nc\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n1\n\n\nNAND真值表：\n\n\n\na\nb\nc\n\n\n\n0\n0\n1\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\nNOR真值表：\n\n\n\na\nb\nc\n\n\n\n0\n0\n1\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n0\n\n\nXOR真值表：\n\n\n\na\nb\nc\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n更复杂的真值表举个例子：三选二表决\n\n\n\na\nb\nc\ny\n\n\n\n0\n0\n0\n0\n\n\n0\n0\n1\n0\n\n\n0\n1\n0\n0\n\n\n0\n1\n1\n1\n\n\n1\n0\n0\n0\n\n\n1\n0\n1\n1\n\n\n1\n1\n0\n1\n\n\n1\n1\n1\n1\n\n\n真值表变成布尔表达式以下根据该真值表，变量为1的话就取变量名，反之取NOT变量名：\n\n\n\na\nb\nc\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\nSoP(积项求和)类似于主析取范式（？），把结果为1的最小项给析取了，即踩中一个最小项就为1。\n\nPoS(和项求积)类似于主和取范式，把结果为0的最大项合取，只有不踩中任何一个最大项才是1。\n\n布尔表达式化简基本定律其实就是离散数学那堆东西：其中最常用的就是分配律\n举个栗子对于这一个式子，电路如下：\n具体过程为：\n\n结果就是a与c的或，相比最初简单了不少。\n组合逻辑的转换大致如ppt上的图所示，除了真值表转电路图比较麻烦之外，其他的其实都很直观：\n电路化简\n遍历建立真值表，之后用SoP或者PoS化简\n写出电路对应表达式，对表达式化简\n\n第一种较为简单，不举例子了。对于第二种来说，化简和之前一样，此处举一个电路对应表达式的例子：\n从输入到输出，依次建立表达式子(标记在线边上)，但是，写式子的时候我觉得应该从输出往回看，因为只有最后那个最大：\n\n由此得知，可以电路化简为：\n卡诺图化简表达式\n\n\n\n\n\n\n\n\n本质：利用相邻项一次化简一个比如和\n步骤：\n\n构建卡诺图，其实就是一个方格，比如五变量的分为2和3，2变量方向有格，3变量方向格\n填1，比如四变量的SoP里面出现了这一项，那么ab（2变量）方向上对应10的格且cd方向上对应01、11的格得标注为1，即坐标为(10,01)(10,11)这俩。\n根据以下规则画圈：\n组内有效单元的个数必须是2的整数幂\n应该选择尽可能大的组\n注意4角的单元\n避免出现单个单元\n\n\n\n举个例子：根据画圈的不同可以化简为：\n\n运算一位加法器对于单独一位来说，加法需要“本位”和“进位”，分别为和，而上一位的进位是：\n\n\n\n\n\n\n\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n1\n0\n\n\n0\n1\n1\n0\n1\n\n\n1\n0\n0\n1\n0\n\n\n1\n0\n1\n0\n1\n\n\n1\n1\n0\n0\n1\n\n\n1\n1\n1\n1\n1\n\n\n对于和各自可以列出SoP形式的式子：\n\n串行加法器对于每个加法器来说，输入是本位的和，上一位的进位也是输入，而输出是本位的值和往下一位的进位，由此组成一个串：\n其中可以看出，第0位的进位为0，因为其之前并没有进位，根本没有数字。\n总结\n门电路：多种逻辑门的表示以及几种化简方法（卡诺图、规则化简）\n运算：构建一个串行加法器\n\n","slug":"buaa-co-pre-2","date":"2024-07-28T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理","author_index":"大仓鼠"},{"id":"ee17b1d2d4f98e58465a0cc1225842a7","title":"北航计组-预习0-预习准备","content":"计组预习-Part0第一天预习就先看一下课程内容，我打算先从课程内容开始，整理一下预习的过程，然后按顺序预习，中途可以补一些题或者看一下教材，主要还是打算用往年课件作为第一次预习的资料，符合我个人习惯一些。\n课程组成目标反正就是学硬件、软硬件协同、设计硬件、从数电到MIPS到MIPS程序\n大概有的课\n概论一节\n组合、时序逻辑（似乎电电B讲过了）\n存储器、存储系统、方式\n指令、汇编\nMIPS不同的课会排在不同的时间，具体看到时候安排吧。\n\n学习内容\n基本原理\n硬件描述语言（HDL）\nVerilog\n软件工具：logisim\n软件工具：MARS\n软硬件调试\n\n预习安排大致上我应该每一讲都会写一次笔记，前面会附上本次课程的目标与内容，顺序上先学习理论课，实验课后续补上，中途我可能会自己穿插一些练习，不再赘述，参考网站我也会附上的。其他有些资源我会扔到OSS上面，有需要的可以看情况下载。\n课程安排应该是预备阶段week1-6，后续是任务阶段week7-17，我打算先把预备阶段准备好，后续P0-P8再说吧，先不急。\n一点疑惑似乎2022课件相比2018课件把存储部分都删了？\n","slug":"buaa-co-pre-0","date":"2024-07-26T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理","author_index":"大仓鼠"},{"id":"b8770cb77afe30b610a74e7f474f90fc","title":"北航计组-预习1-基本认识与数制","content":"基本认识计算机的基本认识发展过程\nENIAC；第一台数字式多用途计算机\n计算炮弹弹道（逃）\n\n\n大型机时代：20c50s-60s\n小型机时代：20c70s\nPC时代：20c80s-21c\n后PC时代：21c之后\n\n重大认识\n层次化表示与解释\n\n\n任何事物都可以表示为数字\n\n\n摩尔定律\n\n\n晶体管数量每两年翻倍\n\n\n局部性与存储层次\n并行性\n性能度量与改进\n\n计算机的应用与分类分类\nPC\n服务器\n服务器集群\n超级计算机\n嵌入式计算机（最大的计算机市场）\n\n计算机的基本硬件构成CPUCPU是计算机的最核心部件，其功能是能够执行由一组指令构成的程序。抽象为两个部分：数据通路、控制器\n\n数据通路：执行指令所需的计算与存储的功能部件集合\nPC：指向要执行的指令\nALU：完成各类计算，如加减乘除\n寄存器堆：临时性存储参与运算的数据以及运算结果\n\n\n控制器：根据指令控制数据通路的各个部件完成相应操作\n\n评价为：数据通路是干活的鼠鼠，控制器是指使干活的可恶猫猫。\n而对于现代主流CPU：通常包含cache、MMU，每个核心相当于过去的一个完整CPU\n主存储器也被称为内存，而CD、硬盘之类的东西叫做外存（辅存）\n早期内存只有几个K，现在动辄以G字节计数。\n计算机的层次结构一个完整的计算机系统，可以划分为硬件和软件两大部分。其中，两者之间的交互界面就是指令集：\n数制常见进制及其转换表示方法对于来说，它的值是：\n\n二进制每一位称之为一个bit。其基为{0,1}\n进制转换其实就是转换前的数一直除以转换后进制的进制数，之后取余数，从最低位到最高位，比如10转2进制：16、8、2进制的互转比较容易，因为刚好可以对应。\n常见术语\n字节byte\n由8个二进制位构成的一个元组，是目前计算机的数据单位\n\n\n字word\n根据计算机的不同而不同，可能是32位、64位等等\n\n\n最高有效位MSB\n最低有效位LSB\n最高有效字节MSB\n最低有效字节LSB\n高在左，低在右\n\n\n\n二进制加法步骤二进制加法与十进制加法原理类似，对应位相加就行，加到2就进位一个1即可：由于一个字的长度是有限制的，比如32位计算机最高位两个1相加，此时就会发生溢出（overflow），一般来说，CPU在溢出发生时，会通过称为异常（exception）的机制来报告这个错误。\n整数的二进制表示方法数字对于一个数字来说，其包含2部分内容:\n\n编码：就是数字本身，或者说是一种记号。例如007\n语义：编码所代表的概念的含义，是对编码的解释\n\n\n\n\n\n\n\n提示\n编码本身没有任何意义，编码只有被赋予语义后才有意义\n\n编码空间\n编码空间：有效编码的集合\n空间大小：有效编码的总数\n对于一个n位B进制数来说，其编码空间大小为\n\n\n\n\n\n\n\n\n\n提示\nQ：对于某个B进制来说，如何确定某个编码方案的编码位数？A：如果对象数量为N，则位数为\n\n二进制无符号数对于二进制无符号数如下：\n二进制符号数原码方案用最高位代表符号，0为正1为负，其余位数为绝对值，比如：\n\n\n\n\n\n\n\n\n\n注意\n\n存在两个0，即和\n有效编码被浪费\n硬件加法难以实现\n\n\n编码数值不连续\n并且在正负区域并非连续增大\n\n\n\n\n\n补码方案用最高位代表符号，0为正1为负，100…000是最小的负数，而111…111是-1\n\n\n\n\n\n\n特点\n\n只有一个0\n符号确定后，数值随编码增长而增长\n\n\n\n表示范围可以为-2147483648到2147483647\n对于一个的N位二进制补码代表的数，它的值为：\n\n\n\n\n\n\n\n小结\n\n现代计算机普遍采用\n使用最高位作为符号位\n负数区间比正数区间多一个数\n相反数计算方法：各位取反，然后加1\n\n\n\n浮点数的二进制表示方法浮点数格式每个浮点数都类似科学计数法可以表述为：\n其中M为尾数，B为基数，E为指数\n\n包含符号S，尾数、指数、基数，其中基数被省略了\n符号一位，0正1负\n指数八位，表示范围\n尾数23位，表示精度\n基数默认为2\n\n我们考虑到二进制尾数的第一位保证是1，如果不是的话说明指数取大了，那么为了优化，我们可以默认尾数最高位为1，这样就可以在尾数里面多一位有效的存储位了，只是计算的时候得补回来，我们以为例：\n此时尾数1.010001101110，我们优化成010001101110\n\n\n\n\n\n\n提示\n绝对值小于1的浮点数的二进制编码对应的数相比其大于1的数更大一些，因为其指数部分是负数，取补码的时候最高位为1，比指数为正的数字会更大一些。\n\n偏阶计数法本质上就是把编码用的指数变成真实指数（的二进制）加上十进制的127，即，此时就可以让对应最小的负指数（即0减去127）了，同时是最大的正指数（255减去127）但是由于一些特殊情况，比如正负无穷和NaN的存在，导致实际上最大正指数是254-127=127，同理最小其实是1-127=-126\n\n\n\n\n\n\n提示\nIEEE754浮点标准即此方法\n\n此时表示范围也很明确了，比如正数范围最大是：，即除了第一位符号位是0，其他位全为1的数字。正数范围最小则为后23位是1，指数为全0的数：\n负数区间和正数区间完全对称，此处略。\n双精度浮点IEEE754还规定了双精度浮点，也就是占据64位的浮点数，与单精度浮点区别如下：\n范围绝对值为从到\n特殊情况编码规则如下表：\n上溢和下溢当一个数绝对值超过了上界就是上溢，当作正负无穷处理，如果绝对值在下界和0之间那就是下溢，当作0来处理\n补码的几种常见运算计算相反数的补码很简单，先算正数的，之后全部取反再加一。比如我们计算-14的补码：\n\n14是\n取反就是\n再加一得到-14的补码：同理，从-14得到14的补码也是取反再加一，这种方法适用于所有求相反数的情况。\n\n减法补码的优势在减法中充分体现：我们知道计算x+y很简单，只需要按位加法就行，只需要一套关于加法的电路，而补码的优势在于求减法的时候x-y可以变成**x+(-y)**，这时候就把减法化成加法和相反数了（在相反数的过程中也只有一次加法）。\n位拓展符号拓展需要先把一位的符号位复制过去到高位，其余对应位数对应复制过去即可。如下：\n符号拓展其实本质是一样的，但是高位全部置0，低位复制过去即可：\n比较=、≠、&gt;、&lt;、≥、≤这六种比较都可以通过&lt;和=符号来实现，此处略，很简单的。\n小于符号的实现我们判断a小于b是通过a-b小于0来实现的，实际使用中判断a-b的符号位即可判断是否小于。\n符号数在一个字是4bit的时候，遇上，的时候，结果会因为溢出，变成，此时符号位变成了1，判断为a比b小，很明显是不对的。对于这种情况我们就需要符号位拓展：\n\n2个N位二进制补码的操作数均扩展1位符号位（即在最高位的左侧加上一位一摸一样的符号位）\n进行N+1位二进制补码的减法计算\n\n此时会发现，符号位为0，那么判断为a比b大，符合实际情况。\n无符号数如果两个数都是无符号数，需要将这俩个数视作符号数之后符号位拓展，并且都拓展一个0即可同上判断了。\n相等符号的实现\n使用XOR运算得到一个c，对c的每一位做OR运算得到一个bit，为1则为假，反之为真\n执行减法运算得到一个c，之后同上\n\n乘法基本原理就是无符号数的乘法。步骤就是先把a和b的绝对值按照无符号数乘法算出来，最后单独判断符号。TODO:讲义内没说怎么做的无符号数乘法，后面再看无符号数乘法和手算乘法一样，但是由于只有0和1更加简单，对应每一位乘数，如果该位为1，则将被乘数复制到位积内，若为0，这该位对应的位积为0，从低位到高位每个乘数的位都进行一次操作，最后按照乘数每一位的位置n，对各个位积向左移位n次，再累加即可。\n除法对于计算机来说除法最难实现，核心是“试商”。对于二进制数，商只会有0和1两种情况，较为简单：\n\n计算商的每位时，仅需做一次减法\n根据减法结果的符号位判断是否够减如下图所示：\n\n无符号数除法流程与上方相同，每次从被除数取出一位，构成中间余数的末位，然后“试商”，用中间余数减去除数，根据结果判断商的这一位是否为1，如果除数有N位，一定记住符号位拓展，中间余数得拓展到N+1位。\n符号数除法先取绝对值做除法，之后单独判断符号，略。\n总结计算机基本认识没啥用，随便看看得了\n数制\n掌握变换数制的方法\n掌握浮点数的编码（1+8+23）\n了解加减乘除运算的原理（都是基于加法（和一些内置运算））\n\n","slug":"buaa-co-pre-1","date":"2024-07-26T16:00:00.000Z","categories_index":"北航计组,学习笔记","tags_index":"计算机组成原理","author_index":"大仓鼠"},{"id":"73415a1b5e681c28d78c3a872e437bc5","title":"折腾笔记-基于GithubPages制作博客里世界","content":"折腾目标当前有什么\n\n\n\n\n\n已经备好了\n一个已经实名的顶级域名\n\n我要干什么\n\n\n\n\n\n目标\n搭建一个Github Page并且和本地HEXO利用git联动建立二级域名CNAME解析到新的博客二级域名SSL安装好网站访问加速（TODO）\n\n折腾开始！建立Github Pages进入Github，点击你的repo进去并且点击new从而新建一个repo。输入你的repository名字，必须为你的用户名.GitHub.io这个格式。其他的选项都可以默认即可进入新建的repo，点击settings，在source选择deploy from a branch至此，GitHub这边初步配置差不多了，目前你访问你的用户名.github.io暂时还不会有反应，因为GitHub pages更新页面需要时间，而且默认会扫描index.html&#x2F;README.md&#x2F;index之类的文件作为首页，但是目前repo是空的，所以不会显示任何内容，但是这是正常的，我们之后会往GitHub上面部署我们的网站。\n\n一点修改（感谢2006-TrickEye）\n其实不一定非要是username.github.io，如果你对你的名字叫做repo的仓库打开GitHub Pages，部署出来的结果会挂到username.github.io&#x2F;repo&#x2F;下面\n\n本地配置hexo首先你需要安装Node.js 和 npm，此处可以参考✨这个网页✨，务必记住配置环境变量，但是你使用这个网页内的Windows Node版本管理器内的nodist的话就不需要自己设置了，安装好直接下一步就好。\n以上安装好之后效果如下，如果没有的话检查一下环境变量的path里面有没有对应的文件夹：\nbash$ npm --version\n10.8.2\n$ node -v\nv20.9.0本地新建文件夹，比如叫做blog，用来存放本地hexo仓库文件，在powershell里面打开这个文件夹。之后的步骤因为不可抗力原因🧱，请使用科学上网，如使用代理的话请输入下面的命令：\nbash$ npm config set proxy http://127.0.0.1:你自己的代理端口\n$ npm config set https-proxy http://127.0.0.1:你自己的代理端口如果你实在没有代理，那么可以换淘宝源：\nbash$ npm config set registry http://registry.npm.taobao.org/\n$ npm config set registry https://registry.npmjs.org/\n\n\n\n\n\n如果你不知道的话有一个小tips\n大部分clash默认http和https的混合端口为7897但是你明明可以点开看一眼的……\n\n之后就可以快乐安装hexo辣！依次输入以下命令即可：\nbash$ npm install -g hexo-cli\n$ hexo init\n$ hexo s\n\n\n\n\n\n\n注意\nhexo init由于需要连接github，但是众所周知会出现网络问题，如果你能连上的话这里就忽略掉吧，连不上的可以按照下面的方法解决。你需要把C:\\Users\\你的电脑用户名\\AppData\\Roaming\\npm\\node_modules\\hexo-cli\\lib\\console\\init.js里面的内容如下修改：\njavascript本来是这样的：\nconst GIT_REPO_URL = &#39;https://github.com/hexojs/hexo-starter.git&#39;;\n你得改成这样：\nconst GIT_REPO_URL = &#39;https://github.com.cnpmjs.org/hexojs/hexo-starter.git&#39;;\n\n在hexo init之后你会发现你的文件夹里面变成了这样：如果略有不同不用担心，我这个已经是部署之后的了，改了好些。之后进浏览器输入localhost:4000，就可以看见默认的hexo静态网页了！\n本地配置git并和GitHub连上之后你需要安装本地的git，如果你是Linux，那么只需要用你系统的包管理器安装即可，此处忽略，如果你是Windows，请去✨官方网页✨下载安装，安装过程全部默认就行，并且同样的，你需要把git给放到环境变量里面。\n但是众所周知，我们网络是十分安全滴，所以你需要设置好ssh来连接。进入git的命令行（git bash），输入：\nbash$ cd ~/.ssh\n$ ssh-keygen -t rsa -C &#39;你GitHub注册用的邮箱地址&#39;这个时候你C盘用户文件夹里面.ssh文件夹中就多了id_rsa和id_rsa.pub这两个文件了，双击用记事本（或者vscode之类的编辑器）打开id_rsa.pub复制里面的key。\n之后进入GitHub网页，右上角头像点开，选择settings：点击SSH and GPG keys，选择New SSH key：之后把你剪贴板复制到key里面就行，名字填任何什么都行。\n最后我们验证+绑定一下：\nbash$ ssh -T git@github.com\n$ git config --global user.name &quot;注册时用户名&quot;\n$ git config --global user.email &quot;注册时邮箱&quot;远程部署hexo回到你的hexo本地目录，编辑一个叫做_config.yml的文件，拉到最下面deploy一项，如下修改：\nymldeploy:\n  type: git\n  repository: https://github.com/你的用户名/你的用户名.GitHub.io.git\n  branch: main修改后即可部署，一般来说你还需要安装一个工具：\nbash$ npm install hexo-deployer-git之后就可以三件套（清理、生成、部署）：\nbash$ hexo clean\n$ hexo g\n$ hexo d耐心等待几分钟之后，你就可以在你的用户名.github.io看见你的网站辣！\n设置dns解析在你的域名提供商那里找到dns解析一项，博主此处以阿里云的万网为例：我们需要添加一条CNAME记录，从而将一个域名解析到另一个域名。\n之后在你的本地hexo文件夹里面的source里面新建一个文件，名字叫做CNAME，无后缀，内容填写为你的域名，比如我的域名是buaa.spotterblog.cn，只需要写进去保存即可，我在此处用的是二级域名，如果你是顶级域名的话也一样写进去即可。\n之后再次三件套就好啦！\nbash$ hexo clean\n$ hexo g\n$ hexo d为了更完美一些，回到你的repo的设置，点到pages里面，我们会发现Custom domain已经变成了我们CNAME这个文件中写的内容了，我们勾选上下方的Enforce HTTPS即可，GitHub会为我们的域名自动申请并安装SSL证书，我们就可以用HTTPS安全的访问我们的博客了！\n折腾总结我们弄好了本地HEXO与git，并且部署到GitHub，利用GitHub Pages托管了我们的网页，同时把自己的域名解析到了GitHub的给我们的域名上，实现了用自己的域名访问。\n一些附加内容由于GitHub Pages访问慢，我们可以把图片挂到各类OSS上，博客文章直接引用外链即可，并且利用CDN来实现加速访问，同时Cloudflare也能实现内地的加速。\n","slug":"net-daily-ssl-domain","date":"2024-07-25T16:00:00.000Z","categories_index":"折腾笔记,网页","tags_index":"GithubPages,SSL,Nginx","author_index":"大仓鼠"}]