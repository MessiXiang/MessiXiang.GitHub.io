{"title":"北航计组-预习9-单周期数据通路工程化方法","uid":"c3f30e18f1c39e433750df61f245507c","slug":"buaa-co-pre-9","date":"2024-08-17T16:00:00.000Z","updated":"2024-08-24T14:33:38.438Z","comments":true,"path":"api/articles/buaa-co-pre-9.json","keywords":null,"cover":"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os1/co1.jpg?x-oss-process=image/resize,w_600","content":"<h1 id=\"CPU形式建模综合方法－－单周期数据通路\"><a href=\"#CPU形式建模综合方法－－单周期数据通路\" class=\"headerlink\" title=\"CPU形式建模综合方法－－单周期数据通路\"></a>CPU形式建模综合方法－－单周期数据通路</h1><h2 id=\"设计方法学概论\"><a href=\"#设计方法学概论\" class=\"headerlink\" title=\"设计方法学概论\"></a>设计方法学概论</h2><h3 id=\"MIPS-C0指令集\"><a href=\"#MIPS-C0指令集\" class=\"headerlink\" title=\"MIPS-C0指令集\"></a>MIPS-C0指令集</h3><p><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co1.png\" alt=\"mipsc0\"></p>\n<p>MIPS-C0可以构造程序设计的绝大多数功能：</p>\n<ul>\n<li><code>lw</code>（I）、<code>sw</code>（I）：存储指令的典型代表</li>\n<li><code>addu</code>（R），<code>subu</code>（R）：运算类指令的典型代表</li>\n<li><code>beq</code>（I）：分支指令的典型代表</li>\n<li><code>jal</code>（J）、<code>jr</code>（R）：支持用的函数</li>\n</ul>\n<p>当然，以上这些指令包含了所有三类指令形式（R，I，J）</p>\n<h3 id=\"MIPS-C0的RTL描述\"><a href=\"#MIPS-C0的RTL描述\" class=\"headerlink\" title=\"MIPS-C0的RTL描述\"></a>MIPS-C0的RTL描述</h3><p>首先，所有指令必须经过取指令的一步：</p>\n<ul>\n<li>R-format：<code>{op, rs, rt, rd, shamt, funct} &lt;- MEM[PC]</code></li>\n<li>I-format：<code>{op, rs, rt, imm16} &lt;- MEM[PC]</code></li>\n<li>J-format：<code>{op, imm26} &lt;- MEM[PC]</code></li>\n</ul>\n<p>对于MIPS-C0来说，很简单就可以写出所有指令的RTL描述：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co2.png\" alt=\"mipsc0rtl\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">回顾一下</p>\n<p>图中<code>jal</code>指令里面写入R[31]的操作实际上就是往<code>$ra</code>里面写，也就是返回地址。</p>\n</div>\n<h3 id=\"形式建模综合方法概述\"><a href=\"#形式建模综合方法概述\" class=\"headerlink\" title=\"形式建模综合方法概述\"></a>形式建模综合方法概述</h3><h4 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h4><ul>\n<li>Q：什么是CPU开发</li>\n<li>A：以某种CPU架构（比如单/多周期、流水线等）为模型，面向给定的指令集，设计并构造出以<strong>Verilog</strong>形式表达的CPU具体实现。</li>\n</ul>\n<p><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co3.png\" alt=\"cpudev\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Verilog是一种硬件描述语言，我把它理解成一种很新的写文章（x），你描述出来之后剩下的事情交给编译器就行。因此画出图再去写代码会更清晰，当然如果你是牛大笔的话也可以忽略……</p></blockquote>\n<ul>\n<li>Q：什么是CPU架构模型</li>\n<li>A：以寄存器堆、ALU等部件为基础，描述各功能部件的基本接口特性以及相互之间的基本连接关系的模型。<ul>\n<li>模型关注功能部件的<em>外特性</em>，即功能部件的某个具体功能与控制的对应关系（不关注具体实现）</li>\n<li>模型也灌注功能部件之间传递信息的基本依赖关系</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"形式建模综合方法要点\"><a href=\"#形式建模综合方法要点\" class=\"headerlink\" title=\"形式建模综合方法要点\"></a>形式建模综合方法要点</h4><ol>\n<li>开发过程基于模型<ul>\n<li>指的是CPU架构（比如单/多周期、流水线等）</li>\n</ul>\n</li>\n<li>开发过程显式地氛围设计和实现两个环节<ul>\n<li>设计：建模每条指令的数据通路和控制信号（当然，我还是建议画画图）</li>\n<li>实现；将设计结果用Verilog表达</li>\n</ul>\n</li>\n<li>基于“系统-子系统”视角的建模层次<ul>\n<li>CPU被视为系统，功能部件是子系统</li>\n</ul>\n</li>\n<li>指令级别独立建模<ul>\n<li>独立分析每条指令的操作，分析数据流、控制流程</li>\n<li>独立构造每条指令的数据通路以及相关功能部件的控制信号</li>\n</ul>\n</li>\n<li>一次性系统级综合<ul>\n<li>将分离的数据通路及控制信号取值<em>高效</em>合成为完整的数据通路和控制器</li>\n</ul>\n</li>\n</ol>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">什么是指令级别独立建模</p>\n<p>删繁就简：我个人认为就是<strong>单独</strong>分析每个指令RTL，分清数据通路和控制信号的各个成分，然后在先前的基础上连接部件即可。</p>\n</div>\n<h4 id=\"建模的基本表示方式\"><a href=\"#建模的基本表示方式\" class=\"headerlink\" title=\"建模的基本表示方式\"></a>建模的基本表示方式</h4><p>数据通路的本质就是一个<strong>连接关系</strong>的集合，比如如下三个部件：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co4.png\" alt=\"mod\"></p>\n<p>此时连接关系就是<code>{&lt;C.C2, A.A1&gt;, &lt;A.A2, B.B1&gt;, &lt;B.B2, C.C1&gt;}</code>。</p>\n<p>当然，你也可以写成表格的形式，表示连接方式的集合：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co5.png\" alt=\"chart\"></p>\n<ul>\n<li>CPU模型确定后，指令的执行路径总体基调就定下来了（比如我们之前提到过的：取指令、译码、计算、访存、回写）</li>\n<li>构成指令执行路径的各个段之间有明确的依赖关系（比如PC驱动IM，ALU算加法后去从DM取值等等）</li>\n</ul>\n<h4 id=\"建模的推理方法\"><a href=\"#建模的推理方法\" class=\"headerlink\" title=\"建模的推理方法\"></a>建模的推理方法</h4><p>正因为我们上文提到的，指令执行过程之中各个块之间存在很强的逻辑依赖关系，建模数据通路的时候可以正向推理，也能<strong>倒推</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>举个栗子：我们需要算无符号加法的时候，要ALU参与，而ALU输入需要两个操作数，得从RF里面取，RF取数又需要译码后的指令，指令译码必须先取指令，取指令需要PC驱动，PC更新需要NPC……<br>由此，就实现了一个倒推。</p></blockquote>\n<p>倒推后，我们可以建立一个表格，包含各个模块的连接方式，比如对于<code>addu</code>来说：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co6.png\" alt=\"addu\"></p>\n<p>第一行为功能部件名字，第二行为功能部件的输入信号，第三行为与该输入信号连接的某个功能部件的输出信号。</p>\n<h2 id=\"指令级别数据通路与控制器建模\"><a href=\"#指令级别数据通路与控制器建模\" class=\"headerlink\" title=\"指令级别数据通路与控制器建模\"></a>指令级别数据通路与控制器建模</h2><h3 id=\"addu建模\"><a href=\"#addu建模\" class=\"headerlink\" title=\"addu建模\"></a>addu建模</h3><p>我在这里还是省掉一些繁文缛节，我们直接开始倒推：</p>\n<ul>\n<li>最后一个环节（-1）：运算结果写入RF，RF需要读一下rd寄存器编号，并且需要控制写入<ul>\n<li>连接关系<code>&lt;ALU.C, RF.WD&gt;, &lt;IM[15:11], RF.A3&gt;</code>，控制信号<code>RFWr = 1</code></li>\n</ul>\n</li>\n<li>前一个环节（-2）：ALU完成加法运算，需要读入两个操作数，以及ALU的控制信号<ul>\n<li>连接关系<code>&lt;RF.RD1, ALU.A&gt;, &lt;RF.RD2, ALU.B&gt;</code>，控制信号<code>ALUOp : 'ADD'</code></li>\n</ul>\n</li>\n<li>-3环节：RF取数，需要读取两个操作数寄存器的编号<ul>\n<li>连接关系<code>&lt;IM[25:21], RF.A1&gt;, &lt;IM[20:16], RF.A2&gt;</code></li>\n</ul>\n</li>\n<li>-4环节：更新PC，并驱动IM取指令，IM需要PC连接，更新PC需要连接NPC，并且PC本身也得给NPC一个输入。<ul>\n<li>连接关系<code>&lt;PC.DO, NPC.PC&gt;, &lt;NPC.NPC, PC.DI&gt;, &lt;PC.DO, IM.A&gt;</code></li>\n</ul>\n</li>\n</ul>\n<p>因此我们可以整理出这样一张表（虽然可能和我上面写的不太一样，不过无所谓啦，以这个为准）：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co8.png\" alt=\"addu_r\"><br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co7.png\" alt=\"addu_r\"></p>\n<h3 id=\"subu建模\"><a href=\"#subu建模\" class=\"headerlink\" title=\"subu建模\"></a>subu建模</h3><p>这里其实和<code>addu</code>十分相关，只有控制信号ALUOp改成SUB即可。<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co9.png\" alt=\"subu_r\"></p>\n<h3 id=\"ori建模\"><a href=\"#ori建模\" class=\"headerlink\" title=\"ori建模\"></a>ori建模</h3><p><code>ori</code>其实也很相似，但是相比R型指令，译码器后面的连线略有不同，并且ALU的操作控制信号取值为OR，还需要一个回写，写到rt里面。因此如下（<strong>回写那步PPT写错了，rd应该是rt</strong>）：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co10.png\" alt=\"ori_r\"></p>\n<h3 id=\"lw建模\"><a href=\"#lw建模\" class=\"headerlink\" title=\"lw建模\"></a>lw建模</h3><p><code>lw</code>有rs、rt寄存器的内容和一个imm16，ALU计算rs寄存器的内容，和imm16做有符号加法后从DM取对应地址的指，回写到rt寄存器里面。需要注意的是，由于是有符号数加法，我们修改了EXT的实现，加入了一个EXTOp的控制信号，因此之前用到EXT的建模都得修改。<br>（<strong>回写那步PPT写错了，rd应该是rt</strong>）<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co11.png\" alt=\"lw_r\"></p>\n<h3 id=\"sw建模\"><a href=\"#sw建模\" class=\"headerlink\" title=\"sw建模\"></a>sw建模</h3><p><code>sw</code>的计算过程和<code>lw</code>差不多，但是具体实现中由于是往DM写入，而不是RF，因此控制信号略有区别：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co12.png\" alt=\"sw_r\"></p>\n<h3 id=\"beq建模\"><a href=\"#beq建模\" class=\"headerlink\" title=\"beq建模\"></a>beq建模</h3><p><code>beq</code>涉及相对跳转的问题，因此需要分线之后直接从IM取出立即数（编译的时候把label会翻译成立即数），然后往NPC里面输入，计算下一个PC，同时需要ALU做一次减法，给出一个判断0出来的zero控制信号：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co13.png\" alt=\"beq_r\"></p>\n<h3 id=\"jal建模\"><a href=\"#jal建模\" class=\"headerlink\" title=\"jal建模\"></a>jal建模</h3><p><code>jal</code>需要改造的控制信号和NPC组件略多一些，当前前面的也需要略微修改：</p>\n<ul>\n<li>输入立即数从16位得扩展到26位</li>\n<li>Br控制信号改成[1:0]NPCOp这两位的控制信号<ul>\n<li><code>2'b00</code>：计算PC+4</li>\n<li><code>2'b01</code>：计算<code>beq</code>地址</li>\n<li><code>2'b10</code>：计算<code>jal</code>地址</li>\n<li><code>2'b11</code>：计算<code>jr</code>地址（后面会用到的<del>米奇妙妙工具</del>）</li>\n</ul>\n</li>\n<li>加入[31:0]PC4信号输出，即输出PC+4，用来写到寄存器堆RF的0x1F号寄存器（31号，也就是<code>$ra</code>）</li>\n<li>其他不变</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>跳回是通过<code>jr</code>实现的。</p>\n</div>\n<p>因此我们可以得到：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co14.png\" alt=\"jal_r\"></p>\n<h3 id=\"jr建模\"><a href=\"#jr建模\" class=\"headerlink\" title=\"jr建模\"></a>jr建模</h3><p><code>jr</code>其实很简单，把rs读出来扔给PC或者NPC即可，但是考虑到“<strong>低耦合，高内聚</strong>”的需求，我们应该让NPC成为唯一会计算PC的部件，因此我们把读出来的值给NPC吧。<br>我们继续修改NPC部件，加入一个[31:0]RA的输入信号，用于输入<code>jr</code>的地址。因此我们得到：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co15.png\" alt=\"jr_r\"></p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>有同学可能会问，哎呀你这个俩控制信号前后不一样啊，在一个时钟周期内咋办。<br>好问题，实际上是覆写的，起作用的只有最后一个控制信号，也就是JR。因为PC有CLK上升沿触发的功能，在上升沿的时候起效的NPCOp就是JR，因此往PC写入的信号就是从RF.RD1接到NPC.RA的信号。</p>\n</div>\n<h2 id=\"数据通路综合方法\"><a href=\"#数据通路综合方法\" class=\"headerlink\" title=\"数据通路综合方法\"></a>数据通路综合方法</h2><h3 id=\"汇聚-综合\"><a href=\"#汇聚-综合\" class=\"headerlink\" title=\"汇聚+综合\"></a>汇聚+综合</h3><p>把所有的指令级别数据通用表汇聚在一张表里面，并总结在最后：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co16.png\" alt=\"com\"></p>\n<p>注意信号之间的覆盖，比如说IM.D[25:0]把IM.D[15:0]覆盖了。</p>\n<h3 id=\"构造MUX\"><a href=\"#构造MUX\" class=\"headerlink\" title=\"构造MUX\"></a>构造MUX</h3><p>我们分析最后一行，输入源大于1个的地方都需要一个MUX选择器，因此我们可以在这一步才加入MUX，方便简单快捷，如下图：<br><img src=\"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os9/co17.png\" alt=\"mux\"></p>\n<p>我们用了三个MUX，分别用不同颜色标记。</p>\n<h3 id=\"编写Verilog\"><a href=\"#编写Verilog\" class=\"headerlink\" title=\"编写Verilog\"></a>编写Verilog</h3><p>我们设置好输入输出信号，verilog里面对PC/NPC/RF/ALU等等module全部做一遍实例化，举例上表的ALU.B的这个输入接的MUX如下：</p>\n<div class=\"language-verilog\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">verilog</span><pre class=\"shiki monokai\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F92672\">wire</span><span style=\"color: #F8F8F2\"> [</span><span style=\"color: #AE81FF\">31</span><span style=\"color: #F8F8F2\">:</span><span style=\"color: #AE81FF\">0</span><span style=\"color: #F8F8F2\">]RD2, Ext, ALU_B;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">RF U_RF(..., RD2, ...);     </span><span style=\"color: #88846F\">// 实例化寄存器堆</span></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">EXT U_EXT(..., Ext, ...);   </span><span style=\"color: #88846F\">// 实例化拓展单元</span></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">ALU U_ALU(..., ALU_B, ...); </span><span style=\"color: #88846F\">// 实例化ALU</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #88846F\">// 实例化二选一MUX</span></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">MUX32_2_1 U_MUX_ALUB(RD2, Ext, ALU_B, ALUBSrc);</span></span></code></pre></div>","feature":false,"text":"L9-CPU形式建模综合方法－－单周期数据通路，咱终于开始手搓CPU了吗？...","permalink":"/post/buaa-co-pre-9","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"北航计组","slug":"北航计组","count":11,"path":"api/categories/北航计组.json"},{"name":"学习笔记","slug":"北航计组/学习笔记","count":11,"path":"api/categories/北航计组/学习笔记.json"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","count":11,"path":"api/tags/计算机组成原理.json"},{"name":"CPU","slug":"CPU","count":4,"path":"api/tags/CPU.json"},{"name":"MIPS","slug":"MIPS","count":6,"path":"api/tags/MIPS.json"},{"name":"数据通路","slug":"数据通路","count":2,"path":"api/tags/数据通路.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CPU%E5%BD%A2%E5%BC%8F%E5%BB%BA%E6%A8%A1%E7%BB%BC%E5%90%88%E6%96%B9%E6%B3%95%EF%BC%8D%EF%BC%8D%E5%8D%95%E5%91%A8%E6%9C%9F%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF\"><span class=\"toc-text\">CPU形式建模综合方法－－单周期数据通路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%AD%A6%E6%A6%82%E8%AE%BA\"><span class=\"toc-text\">设计方法学概论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MIPS-C0%E6%8C%87%E4%BB%A4%E9%9B%86\"><span class=\"toc-text\">MIPS-C0指令集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MIPS-C0%E7%9A%84RTL%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">MIPS-C0的RTL描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%A2%E5%BC%8F%E5%BB%BA%E6%A8%A1%E7%BB%BC%E5%90%88%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">形式建模综合方法概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CPU\"><span class=\"toc-text\">CPU</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BD%A2%E5%BC%8F%E5%BB%BA%E6%A8%A1%E7%BB%BC%E5%90%88%E6%96%B9%E6%B3%95%E8%A6%81%E7%82%B9\"><span class=\"toc-text\">形式建模综合方法要点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BB%BA%E6%A8%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">建模的基本表示方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BB%BA%E6%A8%A1%E7%9A%84%E6%8E%A8%E7%90%86%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">建模的推理方法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%88%AB%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BB%BA%E6%A8%A1\"><span class=\"toc-text\">指令级别数据通路与控制器建模</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#addu%E5%BB%BA%E6%A8%A1\"><span class=\"toc-text\">addu建模</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#subu%E5%BB%BA%E6%A8%A1\"><span class=\"toc-text\">subu建模</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ori%E5%BB%BA%E6%A8%A1\"><span class=\"toc-text\">ori建模</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lw%E5%BB%BA%E6%A8%A1\"><span class=\"toc-text\">lw建模</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sw%E5%BB%BA%E6%A8%A1\"><span class=\"toc-text\">sw建模</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#beq%E5%BB%BA%E6%A8%A1\"><span class=\"toc-text\">beq建模</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jal%E5%BB%BA%E6%A8%A1\"><span class=\"toc-text\">jal建模</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jr%E5%BB%BA%E6%A8%A1\"><span class=\"toc-text\">jr建模</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%BB%BC%E5%90%88%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">数据通路综合方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%87%E8%81%9A-%E7%BB%BC%E5%90%88\"><span class=\"toc-text\">汇聚+综合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0MUX\"><span class=\"toc-text\">构造MUX</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99Verilog\"><span class=\"toc-text\">编写Verilog</span></a></li></ol></li></ol></li></ol>","author":{"name":"大仓鼠","slug":"blog-author","avatar":"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%AB%99%E7%B4%A0%E6%9D%90%E5%9B%BE%E7%89%87/%E5%A4%B4%E5%83%8Flogo/head.jpg","link":"/","description":"我的博客（隐藏版）","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"北航计组-预习10-MIPS单周期控制","uid":"8715491d8376050f4022829c0007c040","slug":"buaa-co-pre-10","date":"2024-08-23T16:00:00.000Z","updated":"2024-09-03T06:32:52.625Z","comments":true,"path":"api/articles/buaa-co-pre-10.json","keywords":null,"cover":"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os1/co1.jpg?x-oss-process=image/resize,w_600","text":"L10-MIPS单周期控制，主要是讲控制信号、时钟信号之类的...","permalink":"/post/buaa-co-pre-10","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"北航计组","slug":"北航计组","count":11,"path":"api/categories/北航计组.json"},{"name":"学习笔记","slug":"北航计组/学习笔记","count":11,"path":"api/categories/北航计组/学习笔记.json"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","count":11,"path":"api/tags/计算机组成原理.json"},{"name":"CPU","slug":"CPU","count":4,"path":"api/tags/CPU.json"},{"name":"MIPS","slug":"MIPS","count":6,"path":"api/tags/MIPS.json"},{"name":"控制","slug":"控制","count":1,"path":"api/tags/控制.json"}],"author":{"name":"大仓鼠","slug":"blog-author","avatar":"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%AB%99%E7%B4%A0%E6%9D%90%E5%9B%BE%E7%89%87/%E5%A4%B4%E5%83%8Flogo/head.jpg","link":"/","description":"我的博客（隐藏版）","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"北航计组-预习8-MIPS数据通路","uid":"0a654409e2cd458ca3e033f4946855b9","slug":"buaa-co-pre-8","date":"2024-08-14T16:00:00.000Z","updated":"2024-09-03T08:44:23.638Z","comments":true,"path":"api/articles/buaa-co-pre-8.json","keywords":null,"cover":"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/buaa/buaa-os1/co1.jpg?x-oss-process=image/resize,w_600","text":"L8-MIPS数据通路，这必须得先学一下Verilog才行，不然看不懂.JPG...","permalink":"/post/buaa-co-pre-8","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"北航计组","slug":"北航计组","count":11,"path":"api/categories/北航计组.json"},{"name":"学习笔记","slug":"北航计组/学习笔记","count":11,"path":"api/categories/北航计组/学习笔记.json"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","count":11,"path":"api/tags/计算机组成原理.json"},{"name":"CPU","slug":"CPU","count":4,"path":"api/tags/CPU.json"},{"name":"MIPS","slug":"MIPS","count":6,"path":"api/tags/MIPS.json"},{"name":"数据通路","slug":"数据通路","count":2,"path":"api/tags/数据通路.json"}],"author":{"name":"大仓鼠","slug":"blog-author","avatar":"https://blogphoto-xyh.oss-cn-chengdu.aliyuncs.com/%E7%BD%91%E7%AB%99%E7%B4%A0%E6%9D%90%E5%9B%BE%E7%89%87/%E5%A4%B4%E5%83%8Flogo/head.jpg","link":"/","description":"我的博客（隐藏版）","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}